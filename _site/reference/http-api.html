<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>HTTP API</title>
    <link rel="stylesheet" href="/css/style.css">
  </head>
  <body>
    <div class="container">
        <header>
            <a href="/"> 
                <img src="/img/logo.svg" alt="Molecula Logo" class="logo">
            </a>
        </header>
        <main class="container__main">
            <!-- Left sidebar -->
            <aside class="container__left">
                <ul>
    
      
        <li><a href="/index.html">Home</a></li>
        
  
      
    
       
        <li><p>Tutorials</a></li>
        
  
      
        <ul>
    
      
        <li><a href="/tutorials/getting-started.html">Getting Started</a></li>
        
  
      
    
  </ul>

      
    
       
        <li><p>Explanation</a></li>
        
  
      
        <ul>
    
      
        <li><a href="/explanations/architecture.html">Architecture</a></li>
        
  
      
    
  </ul>

      
    
       
        <li><p>How-Tos</a></li>
        
  
      
        <ul>
    
      
        <li><a href="/how-tos/install-featurebase.html">Install FeatureBase</a></li>
        
  
      
    
  </ul>

      
    
       
        <li><p>Reference</a></li>
        
  
      
        <ul>
    
       
        <li><p>Interfaces</a></li>
        
  
      
        <ul>
    
      
        <li><a href="/reference/apis.html">APIs</a></li>
        
  
      
    
  </ul>

      
    
       
        <li><p>Query Languages</a></li>
        
  
      
    
       
        <li><p>Operations</a></li>
        
  
      
    
       
        <li><p>Configuration</a></li>
        
  
      
    
      
        <li><a href="/reference/glossary.html">Glossary</a></li>
        
  
      
    
  </ul>

      
    
  </ul>

            </aside>
    
            <article class="container__middle">
                <h1>HTTP API</h1>
                <section>
                  <h2 id="http-api-with-authentication">HTTP API with Authentication</h2>
<p>When authentication is enabled, all HTTP api endpoints and are secured using TLS. All requests must include a valid <code class="language-plaintext highlighter-rouge">Authorization</code> header containing a valid access token. This token may be obtained by following these <a href="/how-tos/enable-auth#how-to-get-auth-token">instructions</a>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl -XGET https://localhost:10101/schema -H "Authorization: Bearer &lt;token&gt;"
</code></pre></div></div>

<h2 id="endpoint-summary">Endpoint summary</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">/cluster/resize/abort</code> (POST)</li>
  <li><code class="language-plaintext highlighter-rouge">/cluster/resize/remove-node</code> (POST)</li>
  <li><code class="language-plaintext highlighter-rouge">/debug/pprof/</code> (GET)</li>
  <li><code class="language-plaintext highlighter-rouge">/debug/vars</code> (GET)</li>
  <li><code class="language-plaintext highlighter-rouge">/metrics</code> (GET), handled by prometheus library</li>
  <li><code class="language-plaintext highlighter-rouge">/metrics.json</code> (GET)</li>
  <li><code class="language-plaintext highlighter-rouge">/export</code> (GET)</li>
  <li><code class="language-plaintext highlighter-rouge">/import-atomic-record</code> (POST)</li>
  <li><code class="language-plaintext highlighter-rouge">/index</code> (GET, POST)</li>
  <li><code class="language-plaintext highlighter-rouge">/index/{index}</code> (GET, POST, DELETE)</li>
  <li><code class="language-plaintext highlighter-rouge">/index/{index}/field</code> (POST)</li>
  <li><code class="language-plaintext highlighter-rouge">/index/{index}/field/{field}</code> (POST, DELETE)</li>
  <li><code class="language-plaintext highlighter-rouge">/index/{index}/field/{field}/import</code> (POST)</li>
  <li><code class="language-plaintext highlighter-rouge">/index/{index}/field/{field}/mutex-check</code> (GET)</li>
  <li><code class="language-plaintext highlighter-rouge">/index/{index}/field/{field}/import-roaring/{shard}</code> (POST)</li>
  <li><code class="language-plaintext highlighter-rouge">/index/{index}/query</code> (POST)</li>
  <li><code class="language-plaintext highlighter-rouge">/info</code> (GET)</li>
  <li><code class="language-plaintext highlighter-rouge">/inspect</code> (GET)</li>
  <li><code class="language-plaintext highlighter-rouge">/recalculate-caches</code> (POST)</li>
  <li><code class="language-plaintext highlighter-rouge">/schema</code> (GET, POST)</li>
  <li><code class="language-plaintext highlighter-rouge">/schema/details</code> (GET)</li>
  <li><code class="language-plaintext highlighter-rouge">/status</code> (GET)</li>
  <li><code class="language-plaintext highlighter-rouge">/transaction</code> (POST)</li>
  <li><code class="language-plaintext highlighter-rouge">/transaction/{id}</code> (GET, POST)</li>
  <li><code class="language-plaintext highlighter-rouge">/transaction/{id}/finish</code> (POST)</li>
  <li><code class="language-plaintext highlighter-rouge">/transactions</code> (GET)</li>
  <li><code class="language-plaintext highlighter-rouge">/queries</code> (GET)</li>
  <li><code class="language-plaintext highlighter-rouge">/query-history</code> (GET)</li>
  <li><code class="language-plaintext highlighter-rouge">/version</code> (GET)</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">/ui</code> endpoints are for UI use and are not necessarily stable:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">/ui/usage</code> (GET)</li>
  <li><code class="language-plaintext highlighter-rouge">/ui/transaction</code> (GET)</li>
  <li><code class="language-plaintext highlighter-rouge">/ui/transaction/</code> (GET)</li>
  <li><code class="language-plaintext highlighter-rouge">/ui/shard-distribution</code> (GET)</li>
</ul>

<h2 id="endpoint-details">Endpoint details</h2>

<h3 id="list-all-index-schemas">List all index schemas</h3>

<p><code class="language-plaintext highlighter-rouge">GET /index</code></p>

<p>Is equivalent to <code class="language-plaintext highlighter-rouge">GET /schema</code> and returns the same response.</p>

<h3 id="list-index-schema">List index schema</h3>

<p><code class="language-plaintext highlighter-rouge">GET /index/{index-name}</code></p>

<p>Returns the schema of the specified index in JSON.</p>

<pre><code class="language-request">curl -XGET localhost:10101/index/user
</code></pre>
<pre><code class="language-response">{
  "name": "user",
  "createdAt": 1591178953061239000,
  "options": {
    "keys": false,
    "trackExistence": true
  },
  "fields": [
    {
      "name": "event",
      "createdAt": 1591178962332452000,
      "options": {
        "type": "set",
        "cacheType": "ranked",
        "cacheSize": 50000,
        "keys": false
      }
    }
  ],
  "shardWidth": 1048576
}
</code></pre>

<h3 id="create-index">Create index</h3>

<p><code class="language-plaintext highlighter-rouge">POST /index/{index-name}</code></p>

<p>Creates an index with the given name.</p>

<p>The request payload is in JSON, and may contain the <code class="language-plaintext highlighter-rouge">options</code> field. The <code class="language-plaintext highlighter-rouge">options</code> field is a JSON object with the following options:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">keys</code> (bool): Enables using column keys instead of column IDs.</li>
  <li><code class="language-plaintext highlighter-rouge">trackExistence</code> (bool): Enables or disables existence tracking on the index. Required for <a href="/reference/pql#not">Not</a> queries. It is <code class="language-plaintext highlighter-rouge">true</code> by default.</li>
</ul>

<pre><code class="language-request">curl -XPOST localhost:10101/index/user -d '{"options":{"keys":true}}'
</code></pre>
<pre><code class="language-response">{"success":true,"name":"user","createdAt":1591179042178854000}
</code></pre>

<h3 id="remove-index">Remove index</h3>

<p><code class="language-plaintext highlighter-rouge">DELETE /index/index-name</code></p>

<p>Removes the given index.</p>

<pre><code class="language-request">curl -XDELETE localhost:10101/index/user
</code></pre>
<pre><code class="language-response">{"success":true}
</code></pre>

<h3 id="query-index">Query index</h3>

<p><code class="language-plaintext highlighter-rouge">POST /index/{index-name}/query</code></p>

<p>Sends a <a href="/reference/pql">query</a> to the FeatureBase server with the given index. The request body is UTF-8 encoded text and response body is in JSON by default.</p>

<pre><code class="language-request">curl localhost:10101/index/user/query \
     -X POST \
     -d 'Row(language=5)'
</code></pre>
<pre><code class="language-response">{
    "results": [
        {
            "columns": [
                100
            ]
        }
    ]
}
</code></pre>

<p>:::note
Prior to Molecula v4.3, the response of a <code class="language-plaintext highlighter-rouge">Row</code> query would also include an “attrs” field.
:::</p>

<p>In order to send protobuf binaries in the request and response, set <code class="language-plaintext highlighter-rouge">Content-Type</code> and <code class="language-plaintext highlighter-rouge">Accept</code> headers to: <code class="language-plaintext highlighter-rouge">application/x-protobuf</code>.</p>

<p>The query is executed for all <a href="/reference/glossary#shard">shards</a> by default. To use specified shards only, set the <code class="language-plaintext highlighter-rouge">shards</code> query argument to a comma-separated list of slice indices.</p>

<pre><code class="language-request">curl "localhost:10101/index/user/query?shards=0,1" \
     -X POST \
     -d 'Row(language=5)'
</code></pre>
<pre><code class="language-response">{
    "results": [
        {
            "columns": [
                100
            ]
        }
    ]
}
</code></pre>

<h3 id="import-data">Import Data</h3>

<p><code class="language-plaintext highlighter-rouge">POST /index/{index-name}/field/{field-name}/import</code></p>

<p>Supports high-rate data ingest to a particular shard of a particular field. Import endpoints are used by ingesters; it is not usually necessary to use this endpoint directly.</p>

<p>The request payload is protobuf encoded with the following schema. The RowKeys
and/or ColumnKeys fields are used if the FeatureBase field or index are configured
for keys respectively. Otherwise, the RowIDs and ColumnIDs fields are used. They
must have the same number of items, and each index into those two lists
represents a particular bit to be set. Timestamps are optional, but if they
exist must also contain the same number of items as rows and columns. The
column IDs must all be in the shard specified in the request.</p>

<p>Some endpoints and data structures include a <code class="language-plaintext highlighter-rouge">CreatedAt</code> fields.
This is typically stored as a timestamp, but it’s purpose is not to inform of the creation date of a particular index or field,
but to serve as a unique identifier for use in cache invalidation.</p>

<p>The problem is that users of FeatureBase (such as <a href="/explanations/ingesters">ingesters</a>)
can usually assume that translation keys for records and field values never change - they are only appended to, and can therefore be trivially cached.
This is true except in cases where an index or field gets deleted and then recreated,
or if FeatureBase is restored from a backup.
So the ingesters must send their current <code class="language-plaintext highlighter-rouge">CreatedAt</code> value which will have changed if either of those two conditions has occured (or if FeatureBase was just restarted),
and the ingester will know that it needs to drop its cache.</p>

<div class="language-protobuf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">message</span> <span class="nc">ImportRequest</span> <span class="p">{</span>
    <span class="kt">string</span> <span class="na">Index</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">string</span> <span class="na">Field</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="kt">uint64</span> <span class="na">Shard</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="k">repeated</span> <span class="kt">uint64</span> <span class="na">RowIDs</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="k">repeated</span> <span class="kt">uint64</span> <span class="na">ColumnIDs</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="k">repeated</span> <span class="kt">int64</span> <span class="na">Timestamps</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
    <span class="k">repeated</span> <span class="kt">string</span> <span class="na">RowKeys</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
    <span class="k">repeated</span> <span class="kt">string</span> <span class="na">ColumnKeys</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
    <span class="kt">int64</span> <span class="na">IndexCreatedAt</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>
    <span class="kt">int64</span> <span class="na">FieldCreatedAt</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="check-mutex-state">Check Mutex State</h3>

<p><code class="language-plaintext highlighter-rouge">GET /index/{index-name}/field/{field-name}/mutex-check</code></p>

<p>Checks the given field for mutex violations, specifically records with more than
one value set. Accepts two optional query parameters:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">details</code> (bool): Report the specific values set, not just the record IDs.</li>
  <li><code class="language-plaintext highlighter-rouge">limit</code> (integer): Limit reporting to the given number of items.</li>
</ul>

<p>The response is a JSON object. If <code class="language-plaintext highlighter-rouge">details</code> is false, the object will be an array
of string values when the index is keyed, or integer values for unkeyed indexes.
If <code class="language-plaintext highlighter-rouge">details</code> is true, it will be an object mapping the string/integer record IDs
to string values for a keyed field, and integer values for an unkeyed field.</p>

<pre><code class="language-request">curl localhost:10101/index/user/field/example/mutex-check \
     -X GET
</code></pre>
<pre><code class="language-response">[
    "record-key1",
    "record-key2"
]
</code></pre>

<pre><code class="language-request">curl localhost:10101/index/user/field/example/mutex-check?details=true \
     -X GET
</code></pre>
<pre><code class="language-response">{
    "record-key1": [
        "value-key1",
        "value-key2"
    ],
    "record-key2": [
        "value-key1",
        "value-key2"
    ]
}
</code></pre>

<h4 id="limitations">Limitations</h4>

<p>When a limit is specified, if different nodes in a cluster have different
conflicting values for a record, not all of those values will be reported;
the accumulation of known conflicts stops once enough conflicting records have
been seen, even though results from other nodes might conceivably add conflicts
to those records.</p>

<p>If no node has multiple values for a record, but two nodes have differing
values for the records, this endpoint does not detect that.</p>

<h3 id="create-field">Create field</h3>

<p><code class="language-plaintext highlighter-rouge">POST /index/{index-name}/field/{field-name}</code></p>

<p>Creates a field in the given index with the given name.</p>

<p>The request payload is in JSON, and may contain the <code class="language-plaintext highlighter-rouge">options</code> field. The <code class="language-plaintext highlighter-rouge">options</code> field is a JSON object which must contain a <code class="language-plaintext highlighter-rouge">type</code>:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">type</code> (string): Sets the field type and type options.</li>
  <li><code class="language-plaintext highlighter-rouge">keys</code> (bool): Enables using column keys instead of column IDs (optional).</li>
</ul>

<p>Valid <code class="language-plaintext highlighter-rouge">type</code>s and correspondonding options are listed below:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">set</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">cacheType</code> (string): <a href="/explanations/data-modeling#ranked">ranked</a> or <a href="/explanations/data-modeling#lru">LRU</a> caching on this field. Default is <code class="language-plaintext highlighter-rouge">ranked</code>.</li>
      <li><code class="language-plaintext highlighter-rouge">cacheSize</code> (int): Number of rows to keep in the cache. Default is 50,000.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">int</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">min</code> (int): Minimum integer value allowed for the field.</li>
      <li><code class="language-plaintext highlighter-rouge">max</code> (int): Maximum integer value allowed for the field.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">timestamp</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">timeUnit</code> (string): <a href="/explanations/data-modeling#timestamp-field-implementation">Granularity</a>. Allowed values are <code class="language-plaintext highlighter-rouge">s</code>, <code class="language-plaintext highlighter-rouge">ms</code>, <code class="language-plaintext highlighter-rouge">us</code>, <code class="language-plaintext highlighter-rouge">ns</code>. <code class="language-plaintext highlighter-rouge">s</code> is the default.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">bool</code>
    <ul>
      <li>(boolean fields take no arguments)</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">time</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">timeQuantum</code> (string): <a href="/explanations/data-modeling#time-quantum">Time Quantum</a> for this field.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">mutex</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">cacheType</code> (string): <a href="/explanations/data-modeling#ranked">ranked</a> or <a href="/explanations/data-modeling#lru">LRU</a> caching on this field. Default is <code class="language-plaintext highlighter-rouge">ranked</code>.</li>
      <li><code class="language-plaintext highlighter-rouge">cacheSize</code> (int): Number of rows to keep in the cache. Default is 50,000.</li>
    </ul>
  </li>
</ul>

<p>The following example creates an <code class="language-plaintext highlighter-rouge">int</code> field called “quantity” capable of storing values from -1000 to 2000:</p>

<pre><code class="language-request">curl localhost:10101/index/user/field/quantity \
     -X POST \
     -d '{"options": {"type": "int", "min": -1000, "max":2000}}'
</code></pre>
<pre><code class="language-response">{"success":true,"name":"quantity","createdAt":1591180110914425000}
</code></pre>

<p>Integer fields are stored as n-bit range-encoded values. FeatureBase supports 63-bit, signed integers with values between <code class="language-plaintext highlighter-rouge">min</code> and <code class="language-plaintext highlighter-rouge">max</code>.</p>

<pre><code class="language-request">curl localhost:10101/index/user/field/language -X POST
</code></pre>
<pre><code class="language-response">{"success":true,"name":"language","createdAt":1591180128294321000}
</code></pre>

<pre><code class="language-request">curl localhost:10101/index/repository/field/stats \
    -X POST \
    -d '{"options":{"type": "int", "min": 0, "max": 1000000}}'
</code></pre>
<pre><code class="language-response">{"success":true,"name":"stats","createdAt":1591180737881627000}
</code></pre>

<h3 id="remove-field">Remove field</h3>

<p><code class="language-plaintext highlighter-rouge">DELETE /index/{index-name}/field/{field-name}</code></p>

<p>Removes the given field.</p>

<pre><code class="language-request">curl -XDELETE localhost:10101/index/user/field/language
</code></pre>
<pre><code class="language-response">{"success":true}
</code></pre>

<h3 id="list-all-index-schemas-1">List all index schemas</h3>

<p><code class="language-plaintext highlighter-rouge">GET /schema</code></p>

<p>Returns the schema of all indexes in JSON.</p>

<pre><code class="language-request">curl -XGET localhost:10101/schema
</code></pre>
<pre><code class="language-response">{
  "indexes": [
    {
      "name": "user",
      "createdAt": 1591178953061239000,
      "options": {
        "keys": false,
        "trackExistence": true
      },
      "fields": [
        {
          "name": "event",
          "createdAt": 1591178962332452000,
          "options": {
            "type": "set",
            "cacheType": "ranked",
            "cacheSize": 50000,
            "keys": false
          }
        },
        {
          "name": "language",
          "createdAt": 1591180128294321000,
          "options": {
            "type": "set",
            "cacheType": "ranked",
            "cacheSize": 50000,
            "keys": false
          }
        },
        {
          "name": "quantity",
          "createdAt": 1591180110914425000,
          "options": {
            "type": "int",
            "base": 0,
            "bitDepth": 0,
            "min": -1000,
            "max": 2000,
            "keys": false,
            "foreignIndex": ""
          }
        }
      ],
      "shardWidth": 1048576
    }
  ]
}
</code></pre>

<!--
### Duplicate schema into empty Pilosa cluster

`POST /schema`

To duplicate one Pilosa cluster's schema to another, it's possible to
pass the output of `GET /schema` as the request body of `POST /schema`
and all the indexes and fields in the schema will be created in
Pilosa.

Note that the `/schema` endpoint is not aware of foreign key relationships
between indexes, so this may not succeed when the schema includes an
index with a foreign key associated with an index that is defined
later in the schema.

The behavior of POSTing a schema to a non-empty Pilosa cluster
is undefined.


``` request
# after (e.g.) curl -XGET localhost:10101/schema > schema.json
curl -XPOST localhost:10101/schema --data-binary @schema.json
```

Response: `204 No Content`
-->

<h3 id="get-version">Get version</h3>

<p><code class="language-plaintext highlighter-rouge">GET /version</code></p>

<p>Returns the version of the FeatureBase server.</p>

<pre><code class="language-request">curl -XGET localhost:10101/version
</code></pre>
<pre><code class="language-response">{"version":"2.0.0-alpha.20-6-gb9d8d6b4"}
</code></pre>

<h3 id="get-status">Get status</h3>

<p><code class="language-plaintext highlighter-rouge">GET /status</code></p>

<p>Returns the status of the cluster.</p>

<pre><code class="language-request">curl -XGET localhost:10101/status
</code></pre>
<pre><code class="language-response">{
  "state": "NORMAL",
  "nodes": [
    {
      "id": "1b018ce0-5de5-4da9-9285-6c4c0d8106f9",
      "uri": {
        "scheme": "http",
        "host": "localhost",
        "port": 10101
      },
      "grpc-uri": {
        "scheme": "http",
        "host": "localhost",
        "port": 20101
      },
      "isCoordinator": true,
      "state": "READY"
    }
  ],
  "localID": "1b018ce0-5de5-4da9-9285-6c4c0d8106f9"
}
</code></pre>

<h3 id="get-active-queries">Get active queries</h3>

<p><code class="language-plaintext highlighter-rouge">GET /queries</code></p>

<p>Returns the set of active queries. Supports pretty printing in <code class="language-plaintext highlighter-rouge">text/plain</code> format or JSON output in <code class="language-plaintext highlighter-rouge">application/json</code> format.
Also includes the amount of time that the query has been running (in nanoseconds when using JSON).</p>

<pre><code class="language-request">curl -XGET localhost:10101/queries
</code></pre>
<pre><code class="language-response">182.412µs  All()
</code></pre>

<pre><code class="language-request">curl -XGET -H "Accept: application/json" localhost:10101/queries
</code></pre>
<pre><code class="language-response">[{"query":"All()","age":135123}]
</code></pre>

<h3 id="get-query-history">Get query history</h3>
<p><code class="language-plaintext highlighter-rouge">GET /query-history</code></p>

<p>Returns a list of objects representing historical queries.</p>

<p>This endpoint supports the query history display in the UI.</p>

<p>Each node maintains a separate list of queries that it served,
of length configured with <code class="language-plaintext highlighter-rouge">--query-history-length</code> (default 100).</p>

<p>The response combines the query history from all nodes, which
results in some duplication of the PQL values, but distinguishable
via the nodeID.</p>

<p>Some entries in the history may result from translated or generated
queries created during the execution process of explicit query requests.</p>

<p><code class="language-plaintext highlighter-rouge">runtimeNanoseconds</code> is the query’s execution time in nanoseconds. Note
that this execution time may not exactly match the <code class="language-plaintext highlighter-rouge">duration</code> value
reported in other contexts.</p>

<pre><code class="language-request">curl -XPOST localhost:10101/query-history
</code></pre>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="w">
  </span><span class="p">{</span><span class="w">
    </span><span class="nl">"PQL"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Count(All())"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"nodeID"</span><span class="p">:</span><span class="w"> </span><span class="s2">"32ce5e768b0d8ca5"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"index"</span><span class="p">:</span><span class="w"> </span><span class="s2">"i"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"start"</span><span class="p">:</span><span class="w"> </span><span class="s2">"2021-04-14T10:42:34.167919-05:00"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"runtimeNanoseconds"</span><span class="p">:</span><span class="w"> </span><span class="mi">344834</span><span class="w">
  </span><span class="p">},</span><span class="w">
  </span><span class="p">{</span><span class="w">
    </span><span class="nl">"PQL"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Count(Row(f&lt;</span><span class="se">\"</span><span class="s2">2021-04-14T15:40:02Z</span><span class="se">\"</span><span class="s2">))"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"nodeID"</span><span class="p">:</span><span class="w"> </span><span class="s2">"32ce5e768b0d8ca5"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"index"</span><span class="p">:</span><span class="w"> </span><span class="s2">"j"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"start"</span><span class="p">:</span><span class="w"> </span><span class="s2">"2021-04-14T10:42:34.167793-05:00"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"runtimeNanoseconds"</span><span class="p">:</span><span class="w"> </span><span class="mi">573245</span><span class="w">
  </span><span class="p">},</span><span class="w">
</span><span class="p">]</span><span class="w">
</span></code></pre></div></div>

<h3 id="recalculate-caches">Recalculate Caches</h3>

<p><code class="language-plaintext highlighter-rouge">POST /recalculate-caches</code></p>

<p>Recalculates the caches for TopN queries on demand. The cache is recalculated every 10
seconds by default. This endpoint can be used to recalculate the cache
before the 10 second interval. This should probably only be used in
integration tests and not in a typical production workflow. Note that
in a multi-node cluster, the cache is only recalculated on the node
that receives the request.</p>

<pre><code class="language-request">curl -XPOST localhost:10101/recalculate-caches
</code></pre>

<p>Response: <code class="language-plaintext highlighter-rouge">204 No Content</code></p>

                </section>
            </article>
    
            <!-- Right sidebar -->
            <nav class="container__right">
                <div>Applies to</div>

                <span>Please <a href="https://github.com/molecula/documentation/edit/gh-pages/reference/http-api.md">help improve this article</a>.</span>

                <div>
                    <span>
                        Modified: 
                    </span>
                </div>

                <div>Feedback?</div>
            </nav>
        </main>
        <footer>
            <p> &copy; 2022 Molecula Corp.</p>
        </footer>
    </div>
  </body>
</html>
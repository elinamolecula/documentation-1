<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>PQL</title>
    <link rel="stylesheet" href="/css/style.css">
  </head>
  <body>
    <div class="container">
        <header>
            <a href="/"> 
                <img src="/img/logo.svg" alt="Molecula Logo" class="logo">
            </a>
        </header>
        <main class="container__main">
            <!-- Left sidebar -->
            <aside class="container__left">
                <ul>
    
      
        <li><a href="/index.html">Home</a></li>
        
  
      
    
       
        <li><p>Tutorials</a></li>
        
  
      
        <ul>
    
      
        <li><a href="/tutorials/getting-started.html">Getting Started</a></li>
        
  
      
    
  </ul>

      
    
       
        <li><p>Explanation</a></li>
        
  
      
        <ul>
    
      
        <li><a href="/explanations/architecture.html">Architecture</a></li>
        
  
      
    
  </ul>

      
    
       
        <li><p>How-Tos</a></li>
        
  
      
        <ul>
    
      
        <li><a href="/how-tos/install-featurebase.html">Install FeatureBase</a></li>
        
  
      
    
  </ul>

      
    
       
        <li><p>Reference</a></li>
        
  
      
        <ul>
    
       
        <li><p>Interfaces</a></li>
        
  
      
        <ul>
    
      
        <li><a href="/reference/apis.html">APIs</a></li>
        
  
      
    
  </ul>

      
    
       
        <li><p>Query Languages</a></li>
        
  
      
    
       
        <li><p>Operations</a></li>
        
  
      
    
       
        <li><p>Configuration</a></li>
        
  
      
    
      
        <li><a href="/reference/glossary.html">Glossary</a></li>
        
  
      
    
  </ul>

      
    
  </ul>

            </aside>
    
            <article class="container__middle">
                <h1>PQL</h1>
                <section>
                  <h2 id="overview">Overview</h2>

<p>This section will provide a detailed reference and examples for the Pilosa Query Language (PQL). Every PQL query has a primary index that it operates on. How this index is specified is protocol dependent (e.g in HTTP it is specified in the query path, over postgres wire protocol it is prepended to the query in square brackets).</p>

<p>A <a href="/explanations/pql-intro">basic introduction to PQL</a> is also available.</p>

<h3 id="conventions">Conventions</h3>

<ul>
  <li>Angle Brackets <code class="language-plaintext highlighter-rouge">&lt;&gt;</code> denote required arguments</li>
  <li>Square Brackets <code class="language-plaintext highlighter-rouge">[]</code> denote optional arguments</li>
  <li>UPPER_CASE denotes a descriptor that will need to be filled in with a concrete value (e.g. <code class="language-plaintext highlighter-rouge">STRING</code>)</li>
</ul>

<h4 id="examples">Examples</h4>

<p>Before running any of the example queries below, follow the instructions in the <a href="/tutorials/getting-started">Getting Started</a> section of the FeatureBase docs to set up an index and fields, and to populate them with some data.</p>

<p>The examples just show the PQL quer(ies) needed - to run the query <code class="language-plaintext highlighter-rouge">Set(10, stargazer=1)</code> against a server using curl, you would:</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl localhost:10101/index/repository/query <span class="se">\</span>
     <span class="nt">-X</span> POST <span class="se">\</span>
     <span class="nt">-d</span> <span class="s1">'Set(10, stargazer=1)'</span>
</code></pre></div></div>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="nl">"results"</span><span class="p">:[</span><span class="kc">true</span><span class="p">]}</span><span class="w">
</span></code></pre></div></div>

<h3 id="arguments-and-types">Arguments and Types</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">field</code> The field specifies on which FeatureBase field the query will operate. Valid field names are lower case strings; they start with a lowercase letter, and contain only alphanumeric characters and <code class="language-plaintext highlighter-rouge">_-</code>. They must be 230 characters or less in length.</li>
  <li><code class="language-plaintext highlighter-rouge">TIMESTAMP</code> This is a timestamp in the following format <code class="language-plaintext highlighter-rouge">YYYY-MM-DDTHH:MM</code> (e.g. 2006-01-02T15:04).</li>
  <li><code class="language-plaintext highlighter-rouge">UINT</code> An unsigned integer (e.g. 42839).</li>
  <li><code class="language-plaintext highlighter-rouge">BOOL</code> A boolean value, <code class="language-plaintext highlighter-rouge">true</code> or <code class="language-plaintext highlighter-rouge">false</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">CALL</code> Any query.</li>
  <li><code class="language-plaintext highlighter-rouge">ROW_CALL</code> Any query which returns a row, such as <code class="language-plaintext highlighter-rouge">Row</code>, <code class="language-plaintext highlighter-rouge">Union</code>, <code class="language-plaintext highlighter-rouge">Difference</code>, <code class="language-plaintext highlighter-rouge">Xor</code>, <code class="language-plaintext highlighter-rouge">Intersect</code>, <code class="language-plaintext highlighter-rouge">Not</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">ROWS_CALL</code> A query that returns a <code class="language-plaintext highlighter-rouge">Rows</code> result (i.e. a list of row IDs). Currently only the <code class="language-plaintext highlighter-rouge">Rows</code> query.</li>
</ul>

<h2 id="row-calls-read">Row Calls (Read)</h2>

<h3 id="row">Row</h3>

<p><strong>Spec:</strong></p>

<pre><code class="language-pql">Row(&lt;FIELD&gt;=&lt;ROW&gt;)
</code></pre>

<p><strong>Description:</strong></p>

<p><code class="language-plaintext highlighter-rouge">Row</code> is a <code class="language-plaintext highlighter-rouge">ROW_QUERY</code> that retrieves the indices of all the columns in a row.</p>

<p><strong>Result Type:</strong> object with columns.</p>

<p>e.g. <code class="language-plaintext highlighter-rouge">{"columns":[10, 20]}</code></p>

<p><strong>Examples:</strong></p>

<p>Query all columns with a bit set in row 1 of the field <code class="language-plaintext highlighter-rouge">stargazer</code> (repositories that are starred by user 1):</p>
<pre><code class="language-pql">Row(stargazer=1)
</code></pre>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="nl">"columns"</span><span class="p">:[</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">20</span><span class="p">]}</span><span class="w">
</span></code></pre></div></div>

<ul>
  <li>columns are the repositories which user 1 has starred.</li>
</ul>

<p>:::note
Prior to Molecula v4.3, the response of a <code class="language-plaintext highlighter-rouge">Row</code> query would also include an “attrs” field.
:::</p>

<h3 id="row-range">Row (Range)</h3>

<p><strong>Spec:</strong></p>

<pre><code class="language-pql">Row(&lt;FIELD&gt;=&lt;ROW&gt;, from=&lt;TIMESTAMP&gt;, to=&lt;TIMESTAMP&gt;)
</code></pre>

<p><strong>Description:</strong></p>

<p>Similar to <code class="language-plaintext highlighter-rouge">Row</code>, but only returns bits which were set with time quantums between the given <code class="language-plaintext highlighter-rouge">from</code> (inclusive) and <code class="language-plaintext highlighter-rouge">to</code> (exclusive) times. Both <code class="language-plaintext highlighter-rouge">from</code> and <code class="language-plaintext highlighter-rouge">to</code> parameters are optional. The default for <code class="language-plaintext highlighter-rouge">to</code> time is current time + 1 day. If a later end time is required, specify it explicitly.</p>

<p><strong>Result Type:</strong> object with columns</p>

<p><strong>Examples:</strong></p>

<p>Query all columns with a bit set in row 1 of a field (repositories that a user has starred), within a date range:</p>
<pre><code class="language-pql">Row(stargazer=1, from='2010-01-01T00:00', to='2017-03-02T03:00')
</code></pre>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="nl">"columns"</span><span class="p">:[</span><span class="mi">10</span><span class="p">]}</span><span class="w">
</span></code></pre></div></div>

<p>This example assumes time quantums have been set on some bits.</p>

<ul>
  <li>columns are repositories which were starred by user 1 in the time range 2010-01-01 to 2017-03-02.</li>
</ul>

<h3 id="row-bsi">Row (BSI)</h3>

<p><strong>Spec:</strong></p>

<pre><code class="language-pql">Row([&lt;COMPARISON_VALUE&gt; &lt;COMPARISON_OPERATOR&gt;] &lt;FIELD&gt; &lt;COMPARISON_OPERATOR&gt; &lt;COMPARISON_VALUE&gt;)
</code></pre>

<p><strong>Description:</strong></p>

<p>The <code class="language-plaintext highlighter-rouge">Row</code> query is overloaded to work on <code class="language-plaintext highlighter-rouge">integer</code> values as well as <code class="language-plaintext highlighter-rouge">timestamp</code> values.
Returns bits that are true for the comparison operator.</p>

<p><strong>Result Type:</strong> object with columns</p>

<p><strong>Examples:</strong></p>

<p>In our source data, <code class="language-plaintext highlighter-rouge">commitactivity</code> was counted over the last year.
The following greater-than <code class="language-plaintext highlighter-rouge">Row</code> query returns all columns with a field value greater than 100 (repositories having more than 100 commits):</p>

<pre><code class="language-pql">Row(commitactivity &gt; 100)
</code></pre>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="nl">"columns"</span><span class="p">:[</span><span class="mi">10</span><span class="p">]}</span><span class="w">
</span></code></pre></div></div>

<ul>
  <li>columns are repositories which had at least 100 commits in the last year.</li>
</ul>

<p>BSI range queries support the following operators:</p>

<table>
  <thead>
    <tr>
      <th>Operator</th>
      <th>Name</th>
      <th>Value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&gt;</code></td>
      <td>greater-than, GT</td>
      <td>integer</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&lt;</code></td>
      <td>less-than, LT</td>
      <td>integer</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&lt;=</code></td>
      <td>less-than-or-equal-to, LTE</td>
      <td>integer</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&gt;=</code></td>
      <td>greater-than-or-equal-to, GTE</td>
      <td>integer</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">==</code></td>
      <td>equal-to, EQ</td>
      <td>integer</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">!=</code></td>
      <td>not-equal-to, NEQ</td>
      <td>integer or <code class="language-plaintext highlighter-rouge">null</code></td>
    </tr>
  </tbody>
</table>

<p>A bounded interval can be specified by chaining the <code class="language-plaintext highlighter-rouge">&lt;</code> and <code class="language-plaintext highlighter-rouge">&lt;=</code> operators (but not others). For example:</p>

<pre><code class="language-pql">Row(50 &lt; commitactivity &lt; 150)
</code></pre>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="nl">"columns"</span><span class="p">:[</span><span class="mi">10</span><span class="p">]}</span><span class="w">
</span></code></pre></div></div>

<p>As of Pilosa 1.0, the “between” syntax <code class="language-plaintext highlighter-rouge">Row(frame=stats, commitactivity &gt;&lt; [50, 150])</code> is no longer supported.</p>

<h3 id="row-timestamp">Row (Timestamp)</h3>

<p><strong>Spec:</strong></p>

<pre><code class="language-pql">Row([&lt;COMPARISON_TIMESTAMP&gt; &lt;COMPARISON_OPERATOR&gt;] &lt;FIELD&gt; &lt;COMPARISON_OPERATOR&gt; &lt;COMPARISON_TIMESTAMP&gt;)
</code></pre>

<p><strong>Description:</strong></p>

<p>The <code class="language-plaintext highlighter-rouge">Row</code> query is overloaded to work on <code class="language-plaintext highlighter-rouge">timestamp</code> values.
Returns bits that are true for the comparison operator.</p>

<p><strong>Result Type:</strong> object with columns</p>

<p><strong>Examples:</strong></p>

<p>In our source data, commitactivity was counted over the last year.
The following greater-than <code class="language-plaintext highlighter-rouge">Row</code> query returns all columns with a field timestamp value greater after Jan 1, 2020:</p>

<pre><code class="language-pql">Row(createdat &gt; '2020-01-01T00:00:00Z')
</code></pre>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="nl">"columns"</span><span class="p">:[</span><span class="mi">10</span><span class="p">]}</span><span class="w">
</span></code></pre></div></div>

<p>Timestamp range queries support the following operators:</p>

<table>
  <thead>
    <tr>
      <th>Operator</th>
      <th>Name</th>
      <th>Value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&gt;</code></td>
      <td>greater-than, GT</td>
      <td>timestamp</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&lt;</code></td>
      <td>less-than, LT</td>
      <td>timestamp</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&lt;=</code></td>
      <td>less-than-or-equal-to, LTE</td>
      <td>timestamp</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&gt;=</code></td>
      <td>greater-than-or-equal-to, GTE</td>
      <td>timestamp</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">==</code></td>
      <td>equal-to, EQ</td>
      <td>timestamp</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">!=</code></td>
      <td>not-equal-to, NEQ</td>
      <td>timestamp or <code class="language-plaintext highlighter-rouge">null</code></td>
    </tr>
  </tbody>
</table>

<p>A bounded interval can be specified by chaining the <code class="language-plaintext highlighter-rouge">&lt;</code> and <code class="language-plaintext highlighter-rouge">&lt;=</code> operators (but not others). For example:</p>

<pre><code class="language-pql">Row(50 &lt; createdat &lt; 150)
</code></pre>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="nl">"columns"</span><span class="p">:[</span><span class="mi">10</span><span class="p">]}</span><span class="w">
</span></code></pre></div></div>

<h3 id="constrow">ConstRow</h3>

<p><strong>Spec:</strong></p>

<pre><code class="language-pql">ConstRow(columns=&lt;[]COLUMN&gt;)
</code></pre>

<p><strong>Description:</strong></p>

<p><code class="language-plaintext highlighter-rouge">ConstRow</code> provides a constant bitmap value that can be used in place of a <code class="language-plaintext highlighter-rouge">Row</code> call.
The columns can be specified as integer IDs or strings.</p>

<p><strong>Result Type:</strong> row value columns.</p>

<p>e.g. <code class="language-plaintext highlighter-rouge">{"columns":[10, 20]}</code></p>

<p><strong>Examples:</strong></p>

<p>Filter specified columns to only those with a bit set in row 1 of the field <code class="language-plaintext highlighter-rouge">stargazer</code> (repositories that are starred by user 1):</p>
<pre><code class="language-pql">Intersect(ConstRow(columns=[10, 20, 30]), Row(stargazer=1))
</code></pre>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="nl">"columns"</span><span class="p">:[</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">20</span><span class="p">]}</span><span class="w">
</span></code></pre></div></div>

<h3 id="all">All</h3>
<p><strong>Spec:</strong></p>

<pre><code class="language-pql">All()
</code></pre>

<p><strong>Description:</strong></p>

<p>All is a <code class="language-plaintext highlighter-rouge">ROW_QUERY</code> that returns the set of all columns in an index that contain any data.</p>

<p>All supports optional <code class="language-plaintext highlighter-rouge">limit</code> and <code class="language-plaintext highlighter-rouge">offset</code> parameters. These are deprecated in favor of the <code class="language-plaintext highlighter-rouge">Limit</code> query.</p>

<p><strong>Result Type:</strong> object with columns</p>

<p><strong>Examples:</strong></p>

<pre><code class="language-pql">All()
</code></pre>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="nl">"columns"</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">361</span><span class="p">,</span><span class="mi">362</span><span class="p">,</span><span class="mi">363</span><span class="p">,</span><span class="mi">364</span><span class="p">,</span><span class="mi">365</span><span class="p">,</span><span class="mi">366</span><span class="p">,</span><span class="mi">367</span><span class="p">,</span><span class="mi">368</span><span class="p">,</span><span class="mi">369</span><span class="p">,</span><span class="mi">370</span><span class="p">,</span><span class="mi">371</span><span class="p">,</span><span class="mi">372</span><span class="p">,</span><span class="mi">373</span><span class="p">,</span><span class="mi">374</span><span class="p">,</span><span class="mi">375</span><span class="p">,</span><span class="mi">376</span><span class="p">,</span><span class="mi">377</span><span class="p">,</span><span class="mi">378</span><span class="p">,</span><span class="mi">379</span><span class="p">,</span><span class="mi">380</span><span class="p">,</span><span class="mi">381</span><span class="p">,</span><span class="mi">382</span><span class="p">,</span><span class="mi">383</span><span class="p">,</span><span class="mi">384</span><span class="p">,</span><span class="mi">385</span><span class="p">,</span><span class="mi">386</span><span class="p">,</span><span class="mi">387</span><span class="p">,</span><span class="mi">388</span><span class="p">,</span><span class="mi">389</span><span class="p">,</span><span class="mi">390</span><span class="p">,</span><span class="mi">391</span><span class="p">,</span><span class="mi">392</span><span class="p">,</span><span class="mi">393</span><span class="p">,</span><span class="mi">394</span><span class="p">,</span><span class="mi">395</span><span class="p">,</span><span class="mi">396</span><span class="p">,</span><span class="mi">397</span><span class="p">,</span><span class="mi">398</span><span class="p">,</span><span class="mi">399</span><span class="p">,</span><span class="mi">400</span><span class="p">,</span><span class="mi">401</span><span class="p">,</span><span class="mi">402</span><span class="p">,</span><span class="mi">403</span><span class="p">,</span><span class="mi">404</span><span class="p">,</span><span class="mi">405</span><span class="p">,</span><span class="mi">406</span><span class="p">,</span><span class="mi">407</span><span class="p">,</span><span class="mi">408</span><span class="p">,</span><span class="mi">409</span><span class="p">,</span><span class="mi">410</span><span class="p">,</span><span class="mi">411</span><span class="p">,</span><span class="mi">412</span><span class="p">,</span><span class="mi">413</span><span class="p">,</span><span class="mi">414</span><span class="p">,</span><span class="mi">415</span><span class="p">,</span><span class="mi">416</span><span class="p">,</span><span class="mi">417</span><span class="p">,</span><span class="mi">418</span><span class="p">,</span><span class="mi">419</span><span class="p">,</span><span class="mi">420</span><span class="p">,</span><span class="mi">421</span><span class="p">,</span><span class="mi">422</span><span class="p">,</span><span class="mi">423</span><span class="p">,</span><span class="mi">424</span><span class="p">,</span><span class="mi">425</span><span class="p">,</span><span class="mi">426</span><span class="p">,</span><span class="mi">427</span><span class="p">,</span><span class="mi">428</span><span class="p">,</span><span class="mi">429</span><span class="p">,</span><span class="mi">430</span><span class="p">,</span><span class="mi">431</span><span class="p">,</span><span class="mi">432</span><span class="p">,</span><span class="mi">433</span><span class="p">,</span><span class="mi">434</span><span class="p">,</span><span class="mi">435</span><span class="p">,</span><span class="mi">436</span><span class="p">,</span><span class="mi">437</span><span class="p">,</span><span class="mi">438</span><span class="p">,</span><span class="mi">439</span><span class="p">,</span><span class="mi">440</span><span class="p">,</span><span class="mi">441</span><span class="p">,</span><span class="mi">442</span><span class="p">,</span><span class="mi">443</span><span class="p">,</span><span class="mi">444</span><span class="p">,</span><span class="mi">445</span><span class="p">,</span><span class="mi">446</span><span class="p">,</span><span class="mi">447</span><span class="p">,</span><span class="mi">448</span><span class="p">,</span><span class="mi">449</span><span class="p">,</span><span class="mi">450</span><span class="p">,</span><span class="mi">451</span><span class="p">,</span><span class="mi">452</span><span class="p">,</span><span class="mi">453</span><span class="p">,</span><span class="mi">454</span><span class="p">,</span><span class="mi">455</span><span class="p">,</span><span class="mi">456</span><span class="p">,</span><span class="mi">457</span><span class="p">,</span><span class="mi">458</span><span class="p">,</span><span class="mi">459</span><span class="p">,</span><span class="mi">460</span><span class="p">,</span><span class="mi">461</span><span class="p">,</span><span class="mi">462</span><span class="p">,</span><span class="mi">463</span><span class="p">,</span><span class="mi">464</span><span class="p">,</span><span class="mi">465</span><span class="p">,</span><span class="mi">466</span><span class="p">,</span><span class="mi">467</span><span class="p">,</span><span class="mi">468</span><span class="p">,</span><span class="mi">469</span><span class="p">,</span><span class="mi">470</span><span class="p">,</span><span class="mi">471</span><span class="p">,</span><span class="mi">472</span><span class="p">,</span><span class="mi">473</span><span class="p">,</span><span class="mi">474</span><span class="p">,</span><span class="mi">475</span><span class="p">,</span><span class="mi">476</span><span class="p">,</span><span class="mi">477</span><span class="p">,</span><span class="mi">478</span><span class="p">,</span><span class="mi">479</span><span class="p">,</span><span class="mi">480</span><span class="p">,</span><span class="mi">481</span><span class="p">,</span><span class="mi">482</span><span class="p">,</span><span class="mi">483</span><span class="p">,</span><span class="mi">484</span><span class="p">,</span><span class="mi">485</span><span class="p">,</span><span class="mi">486</span><span class="p">,</span><span class="mi">487</span><span class="p">,</span><span class="mi">488</span><span class="p">,</span><span class="mi">489</span><span class="p">,</span><span class="mi">490</span><span class="p">,</span><span class="mi">491</span><span class="p">,</span><span class="mi">492</span><span class="p">,</span><span class="mi">493</span><span class="p">,</span><span class="mi">494</span><span class="p">,</span><span class="mi">495</span><span class="p">,</span><span class="mi">496</span><span class="p">,</span><span class="mi">497</span><span class="p">,</span><span class="mi">498</span><span class="p">,</span><span class="mi">499</span><span class="p">,</span><span class="mi">500</span><span class="p">,</span><span class="mi">501</span><span class="p">,</span><span class="mi">502</span><span class="p">,</span><span class="mi">503</span><span class="p">,</span><span class="mi">504</span><span class="p">,</span><span class="mi">505</span><span class="p">,</span><span class="mi">506</span><span class="p">,</span><span class="mi">507</span><span class="p">,</span><span class="mi">508</span><span class="p">,</span><span class="mi">509</span><span class="p">,</span><span class="mi">510</span><span class="p">,</span><span class="mi">511</span><span class="p">,</span><span class="mi">512</span><span class="p">,</span><span class="mi">513</span><span class="p">,</span><span class="mi">514</span><span class="p">,</span><span class="mi">515</span><span class="p">,</span><span class="mi">516</span><span class="p">]}</span><span class="w">
</span></code></pre></div></div>

<h3 id="limit">Limit</h3>

<p><strong>Spec:</strong></p>

<pre><code class="language-pql">Limit(&lt;ROW_CALL&gt;, [limit=&lt;UINT&gt;], [offset=&lt;UINT&gt;])
</code></pre>

<p><strong>Description:</strong></p>

<p>Limit executes a <code class="language-plaintext highlighter-rouge">ROW_CALL</code> and returns a subset of the results.
If a limit of <code class="language-plaintext highlighter-rouge">n</code> is specified, then this query will return the first <code class="language-plaintext highlighter-rouge">n</code> results of the row call.
If an offset of <code class="language-plaintext highlighter-rouge">m</code> is specified, then this query will skip the first <code class="language-plaintext highlighter-rouge">m</code> results of the row call.
If both a limit and offset are specified, the offset is applied before the limit.
This can be used to implement pagination.</p>

<p>:::note
An offset of 0 returns everything, and a limit of 0 returns nothing.
:::</p>

<p><strong>Result Type:</strong> object with columns</p>

<p><strong>Examples:</strong></p>

<p>Find the first column that has a bit set in the given row.</p>
<pre><code class="language-pql">Limit(Row(stargazer=1), limit=1)
</code></pre>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="nl">"results"</span><span class="p">:[{</span><span class="nl">"columns"</span><span class="p">:[</span><span class="mi">20</span><span class="p">]}]}</span><span class="w">
</span></code></pre></div></div>

<p>Find the second column that has a bit set in the given row.</p>
<pre><code class="language-pql">Limit(Row(stargazer=1), limit=1, offset=1)
</code></pre>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="nl">"results"</span><span class="p">:[{</span><span class="nl">"columns"</span><span class="p">:[</span><span class="mi">30</span><span class="p">]}]}</span><span class="w">
</span></code></pre></div></div>

<ul>
  <li>columns are repositories that were starred by user 1</li>
</ul>

<h3 id="union">Union</h3>

<p><strong>Spec:</strong></p>

<pre><code class="language-pql">Union([ROW_CALL ...])
</code></pre>

<p><strong>Description:</strong></p>

<p>Union is a <code class="language-plaintext highlighter-rouge">ROW_CALL</code> that performs a set union on the column indexes in the results of all <code class="language-plaintext highlighter-rouge">ROW_CALL</code> queries passed to it. In comparison to a relational query, this is similar to combining clauses in the “OR” sense.</p>

<p><strong>Result Type:</strong> object with columns</p>

<p><strong>Examples:</strong></p>

<p>Query columns with a bit set in either of two rows (repositories that are starred by either of two users):</p>
<pre><code class="language-pql">Union(Row(stargazer=1), Row(stargazer=2))
</code></pre>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="nl">"columns"</span><span class="p">:[</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">20</span><span class="p">,</span><span class="w"> </span><span class="mi">30</span><span class="p">]}</span><span class="w">
</span></code></pre></div></div>

<ul>
  <li>columns are repositories that were starred by user 1 OR user 2</li>
</ul>

<h3 id="intersect">Intersect</h3>

<p><strong>Spec:</strong></p>

<pre><code class="language-pql">Intersect(&lt;ROW_CALL&gt;, [ROW_CALL ...])
</code></pre>

<p><strong>Description:</strong></p>

<p>Intersect is a <code class="language-plaintext highlighter-rouge">ROW_CALL</code> that performs a set intersection on the column indexes in the results of all <code class="language-plaintext highlighter-rouge">ROW_CALL</code> queries passed to it. In comparison to a relational query, this is similar to combining clauses in the “AND” sense.</p>

<p><strong>Result Type:</strong> object with columns</p>

<p><strong>Examples:</strong></p>

<p>Query columns with a bit set in both of two rows (repositories that are starred by both of two users):</p>

<pre><code class="language-pql">Intersect(Row(stargazer=1), Row(stargazer=2))
</code></pre>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="nl">"columns"</span><span class="p">:[</span><span class="mi">10</span><span class="p">]}</span><span class="w">
</span></code></pre></div></div>

<ul>
  <li>columns are repositories that were starred by user 1 AND user 2</li>
</ul>

<h3 id="difference">Difference</h3>

<p><strong>Spec:</strong></p>

<pre><code class="language-pql">Difference(&lt;ROW_CALL&gt;, [ROW_CALL ...])
</code></pre>

<p><strong>Description:</strong></p>

<p>Difference is a <code class="language-plaintext highlighter-rouge">ROW_CALL</code> that performs a set difference on the column indexes in the results of the <code class="language-plaintext highlighter-rouge">ROW_CALL</code> queries passed to it. It returns all column indexes that are present in the first <code class="language-plaintext highlighter-rouge">ROW_CALL</code> argument passed to it, and not present in any of the subsequent <code class="language-plaintext highlighter-rouge">ROW_CALL</code> arguments.</p>

<p><strong>Result Type:</strong> object with columns</p>

<p><strong>Examples:</strong></p>

<p>Query columns with a bit set in one row and not another (repositories that are starred by one user and not another):</p>
<pre><code class="language-pql">Difference(Row(stargazer=1), Row(stargazer=2))
</code></pre>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="nl">"columns"</span><span class="p">:[</span><span class="mi">20</span><span class="p">]}</span><span class="w">
</span></code></pre></div></div>

<ul>
  <li>columns are repositories that were starred by user 1 BUT NOT user 2</li>
</ul>

<p>Query for the opposite difference:</p>
<pre><code class="language-pql">Difference(Row(stargazer=2), Row(stargazer=1))
</code></pre>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="nl">"columns"</span><span class="p">:[</span><span class="mi">30</span><span class="p">]}</span><span class="w">
</span></code></pre></div></div>

<ul>
  <li>columns are repositories that were starred by user 2 BUT NOT user 1</li>
</ul>

<h3 id="xor">Xor</h3>

<p><strong>Spec:</strong></p>

<pre><code class="language-pql">Xor(&lt;ROW_CALL&gt;, [ROW_CALL ...])
</code></pre>

<p><strong>Description:</strong></p>

<p>Xor is a <code class="language-plaintext highlighter-rouge">ROW_CALL</code> that performs a <a href="https://en.wikipedia.org/wiki/Symmetric_difference">symmetric difference</a> on the column indexes in the results of all <code class="language-plaintext highlighter-rouge">ROW_CALL</code> queries passed to it. For example, with two arguments, it returns all column indexes that are present in the results of <em>either</em> of its arguments, but not <em>both</em> of them.</p>

<p><strong>Result Type:</strong> object with columns</p>

<p><strong>Examples:</strong></p>

<p>Query columns with a bit set in exactly one of two rows (repositories that are starred by only one of two users):</p>

<pre><code class="language-pql">Xor(Row(stargazer=2), Row(stargazer=1))
</code></pre>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="nl">"columns"</span><span class="p">:[</span><span class="mi">20</span><span class="p">,</span><span class="mi">30</span><span class="p">]}</span><span class="w">
</span></code></pre></div></div>

<ul>
  <li>columns are repositories that were starred by user 1 XOR user 2 (user 1 or user 2, but not both)</li>
</ul>

<h3 id="not">Not</h3>

<p><strong>Spec:</strong></p>

<pre><code class="language-pql">Not(&lt;ROW_CALL&gt;)
</code></pre>

<p><strong>Description:</strong></p>

<p>Not is a <code class="language-plaintext highlighter-rouge">ROW_CALL</code> that performs a set complement on the results from its single <code class="language-plaintext highlighter-rouge">ROW_CALL</code> argument. This is conceptually equivalent to a difference between the <a href="https://mathworld.wolfram.com/UniversalSet.html">universal set</a> and the argument.</p>

<p><strong>Result Type:</strong> object with columns</p>

<p><strong>Examples:</strong></p>

<p>Query existing columns that do not have a bit set in the given row.</p>
<pre><code class="language-pql">Not(Row(stargazer=1))
</code></pre>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="nl">"columns"</span><span class="p">:[</span><span class="mi">30</span><span class="p">]}</span><span class="w">
</span></code></pre></div></div>

<ul>
  <li>columns are repositories that were not starred by user 1</li>
</ul>

<h3 id="unionrows">UnionRows</h3>

<p><strong>Spec:</strong></p>

<pre><code class="language-pql">UnionRows([ROWS_CALL ...])
</code></pre>

<p><strong>Description:</strong></p>

<p>UnionRows is a <code class="language-plaintext highlighter-rouge">ROW_CALL</code> that performs a set union on the rows matched by the results of all <code class="language-plaintext highlighter-rouge">ROWS_CALL</code> queries passed to it.</p>

<p><strong>Result Type:</strong> object with columns</p>

<p><strong>Examples:</strong></p>

<p>Query columns with a bit set in any row (repositories that are starred by any user):</p>
<pre><code class="language-pql">UnionRows(Rows(stargazer))
</code></pre>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="nl">"columns"</span><span class="p">:[</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">20</span><span class="p">,</span><span class="w"> </span><span class="mi">30</span><span class="p">]}</span><span class="w">
</span></code></pre></div></div>

<ul>
  <li>columns are repositories that were starred by any user</li>
</ul>

<h2 id="row-like-calls-read">Row-like Calls (Read)</h2>

<h3 id="distinct">Distinct</h3>

<p><strong>Spec:</strong></p>

<pre><code class="language-pql">Distinct([ROW_CALL], field=&lt;INT_FIELD&gt;, [index=&lt;INDEX_NAME&gt;])
</code></pre>

<p><strong>Description:</strong></p>

<p>Distinct returns the set of distinct integers in the specified integer field from the set of records specified by the <code class="language-plaintext highlighter-rouge">ROW_CALL</code>. Distinct may operate on a separate index from the one which is being queried, and its result can be used like a <code class="language-plaintext highlighter-rouge">ROW_CALL</code> on the index from the outer query, in this case, Distinct can act like a SQL JOIN.</p>

<p>For example, if you had an index for “Customers”, and one for “Orders”, each order would have an integer customer ID. You could query for orders of a certain type, get the distinct set of customer IDs associated, and then filter down those customers by attributes from the “Customers” index.</p>

<p><strong>Result Type:</strong> The contents of the Distinct result are similar to the result from a <code class="language-plaintext highlighter-rouge">ROW_CALL</code>, including an array of columns. These results are separated into two groups, one for negative values and one for positive. This structure is necessary to accomodate signed values that are represented with bitsets.</p>

<p><strong>Examples:</strong></p>

<p>Simple Distinct call:</p>

<pre><code class="language-pql">Distinct(field=int)
</code></pre>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"neg"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"columns"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
       </span><span class="mi">431</span><span class="p">,</span><span class="w">
       </span><span class="mi">844</span><span class="p">,</span><span class="w">
      </span><span class="mi">1032</span><span class="p">,</span><span class="w">
      </span><span class="mi">1249</span><span class="p">,</span><span class="w">
      </span><span class="mi">1409</span><span class="p">,</span><span class="w">
      </span><span class="mi">8888</span><span class="p">,</span><span class="w">
      </span><span class="mi">8970</span><span class="p">,</span><span class="w">
      </span><span class="mi">9100</span><span class="p">,</span><span class="w">
      </span><span class="mi">9207</span><span class="w">
    </span><span class="p">]</span><span class="w">
  </span><span class="p">},</span><span class="w">
  </span><span class="nl">"pos"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"columns"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
        </span><span class="mi">307</span><span class="p">,</span><span class="w">
        </span><span class="mi">938</span><span class="p">,</span><span class="w">
       </span><span class="mi">4015</span><span class="p">,</span><span class="w">
       </span><span class="mi">7045</span><span class="p">,</span><span class="w">
      </span><span class="mi">86799</span><span class="p">,</span><span class="w">
      </span><span class="mi">87587</span><span class="p">,</span><span class="w">
      </span><span class="mi">88117</span><span class="w">
    </span><span class="p">]</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Distinct call with a <code class="language-plaintext highlighter-rouge">ROW_CALL</code> argument for more specific results:</p>

<pre><code class="language-pql">Distinct(Row(int&gt;0), field=int)
</code></pre>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="w">    </span><span class="p">{</span><span class="w">
      </span><span class="nl">"neg"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nl">"columns"</span><span class="p">:</span><span class="w"> </span><span class="p">[]</span><span class="w">
      </span><span class="p">},</span><span class="w">
      </span><span class="nl">"pos"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nl">"columns"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
          </span><span class="mi">6664</span><span class="p">,</span><span class="w">
          </span><span class="mi">9520</span><span class="p">,</span><span class="w">
          </span><span class="mi">49400</span><span class="p">,</span><span class="w">
          </span><span class="mi">16700</span><span class="p">,</span><span class="w">
          </span><span class="mi">42700</span><span class="p">,</span><span class="w">
          </span><span class="mi">213800</span><span class="p">,</span><span class="w">
        </span><span class="p">]</span><span class="w">
      </span><span class="p">}</span><span class="w">
    </span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Distinct can be composed much like a <code class="language-plaintext highlighter-rouge">ROW_CALL</code>. The following query returns the set of customers in the “east” region who have at least one “domestic” type order:</p>
<pre><code class="language-pql">Intersect(Row(customer_region=east), Distinct(Row(order_type=domestic), field=customer_id, index=orders))
</code></pre>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="nl">"columns"</span><span class="p">:[</span><span class="mi">104</span><span class="p">,</span><span class="w"> </span><span class="mi">115</span><span class="p">,</span><span class="w"> </span><span class="mi">127</span><span class="p">,</span><span class="w"> </span><span class="mi">257</span><span class="p">,</span><span class="w"> </span><span class="mi">265</span><span class="p">,</span><span class="w"> </span><span class="mi">386</span><span class="p">,</span><span class="w"> </span><span class="mi">728</span><span class="p">,</span><span class="w"> </span><span class="mi">783</span><span class="p">,</span><span class="w"> </span><span class="mi">803</span><span class="p">,</span><span class="w"> </span><span class="mi">814</span><span class="p">,</span><span class="w"> </span><span class="mi">952</span><span class="p">]}</span><span class="w">
</span></code></pre></div></div>

<h2 id="rows-calls-read">Rows Calls (Read)</h2>

<h3 id="rows">Rows</h3>

<p><strong>Spec:</strong></p>

<pre><code class="language-pql">Rows(&lt;FIELD&gt;, previous=&lt;UINT|STRING&gt;, limit=&lt;UINT&gt;, column=&lt;UINT|STRING&gt;, from=&lt;TIMESTAMP&gt;, to=&lt;TIMESTAMP&gt;, like=&lt;STRING&gt;)
</code></pre>

<p><strong>Description:</strong></p>

<p>Rows returns a list of row IDs in the given field which have at least one bit
set. The field argument is mandatory, the others are optional.</p>

<p>Rows is only supported on <code class="language-plaintext highlighter-rouge">set</code>, <code class="language-plaintext highlighter-rouge">time</code>, and <code class="language-plaintext highlighter-rouge">mutex</code> fields.</p>

<p>If <code class="language-plaintext highlighter-rouge">previous</code> is given, rows prior to and including the specified row ID or
key will not be returned. If <code class="language-plaintext highlighter-rouge">column</code> is given, only rows which have a set bit
in the given column will be returned. <code class="language-plaintext highlighter-rouge">previous</code> or <code class="language-plaintext highlighter-rouge">column</code> must be strings if
and only if the field or index respectively is using key translation. If <code class="language-plaintext highlighter-rouge">limit</code>
is given, the number of rowIDs returned will be less than or equal to
<code class="language-plaintext highlighter-rouge">limit</code>. The combination of <code class="language-plaintext highlighter-rouge">limit</code> and <code class="language-plaintext highlighter-rouge">previous</code> allows for paging over large
result sets. Results are always ordered, so setting <code class="language-plaintext highlighter-rouge">previous</code> as the last
result of the previous request will start from the next available row.</p>

<p>If the field is of type <code class="language-plaintext highlighter-rouge">time</code>, the <code class="language-plaintext highlighter-rouge">from</code> and <code class="language-plaintext highlighter-rouge">to</code> arguments can be provided
to restrict the result to a specific time span. If <code class="language-plaintext highlighter-rouge">from</code> and <code class="language-plaintext highlighter-rouge">to</code> are
not provided, the full range of existing data will be queried.</p>

<p>If <code class="language-plaintext highlighter-rouge">like</code> is given, only keys matching a pattern will be selected.
A <code class="language-plaintext highlighter-rouge">like</code> pattern may use <code class="language-plaintext highlighter-rouge">_</code> as a placeholder to match a single UTF-8 codepoint, and <code class="language-plaintext highlighter-rouge">%</code> to match 0 or more codepoints.
All other characters will be matched exactly.
For example:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">%</code> - match everything</li>
  <li><code class="language-plaintext highlighter-rouge">_</code> - match all single-codepoint keys</li>
  <li><code class="language-plaintext highlighter-rouge">_%_</code>, <code class="language-plaintext highlighter-rouge">__%</code>, or <code class="language-plaintext highlighter-rouge">%__</code> - match all keys with at least two unicode codepoints</li>
  <li><code class="language-plaintext highlighter-rouge">%a%</code> - match all keys containing at least one instance of the letter <code class="language-plaintext highlighter-rouge">a</code> (when using NFD-format unicode, this will also match <code class="language-plaintext highlighter-rouge">á</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">a_c</code> - match any 3-letter key starting with <code class="language-plaintext highlighter-rouge">a</code> and ending with <code class="language-plaintext highlighter-rouge">c</code></li>
  <li><code class="language-plaintext highlighter-rouge">yes</code> - match the key <code class="language-plaintext highlighter-rouge">yes</code> exactly</li>
</ul>

<p><strong>Result Type:</strong> Object with “rows” or “keys” and an array of integers or strings respectively.</p>

<p><strong>Examples:</strong></p>

<p>Without keys:</p>
<pre><code class="language-pql">Rows(age)
</code></pre>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="nl">"rows"</span><span class="p">:[</span><span class="mi">18</span><span class="p">,</span><span class="mi">22</span><span class="p">,</span><span class="mi">29</span><span class="p">]}</span><span class="w">
</span></code></pre></div></div>

<p>With keys:</p>
<pre><code class="language-pql">Rows(job)
</code></pre>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="nl">"rows"</span><span class="p">:</span><span class="kc">null</span><span class="p">,</span><span class="nl">"keys"</span><span class="p">:[</span><span class="s2">"engineer"</span><span class="p">,</span><span class="s2">"management"</span><span class="p">,</span><span class="s2">"student"</span><span class="p">]}</span><span class="w">
</span></code></pre></div></div>

<p>With <code class="language-plaintext highlighter-rouge">like</code>:</p>
<pre><code class="language-pql">Rows(job, like="%t")
</code></pre>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="nl">"rows"</span><span class="p">:</span><span class="kc">null</span><span class="p">,</span><span class="nl">"keys"</span><span class="p">:[</span><span class="s2">"management"</span><span class="p">,</span><span class="s2">"student"</span><span class="p">]}</span><span class="w">
</span></code></pre></div></div>

<h2 id="membership-calls-read">Membership Calls (Read)</h2>

<h3 id="includescolumn">IncludesColumn</h3>

<p><strong>Spec:</strong></p>

<pre><code class="language-pql">IncludesColumn(&lt;ROW_CALL&gt;, column=&lt;UINT|STRING&gt;)
</code></pre>

<p><strong>Description:</strong></p>

<p>IncludesColumn returns a boolean indicating whether <code class="language-plaintext highlighter-rouge">column</code> is a member of the result set determined by <code class="language-plaintext highlighter-rouge">ROW_CALL</code>. A more appropriate name might be <code class="language-plaintext highlighter-rouge">IncludesRecord</code>; column is old (and confusing!) terminology for a record in FeatureBase and will be renamed in the future.</p>

<p><strong>Result Type:</strong> boolean</p>

<p><strong>Examples:</strong></p>

<pre><code class="language-pql">IncludesColumn(Row(language=1), column=1)
</code></pre>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kc">true</span><span class="w">
</span></code></pre></div></div>

<h2 id="count-calls-read">Count Calls (Read)</h2>

<h3 id="count">Count</h3>
<p><strong>Spec:</strong></p>

<pre><code class="language-pql">Count(&lt;ROW_CALL&gt;)
</code></pre>

<p><strong>Description:</strong></p>

<p>Returns the number of set bits in the <code class="language-plaintext highlighter-rouge">ROW_CALL</code> passed in.</p>

<p><strong>Result Type:</strong> int</p>

<p><strong>Examples:</strong></p>

<p>Query the number of bits set in a row (the number of repositories a user has starred):</p>
<pre><code class="language-pql">Count(Row(stargazer=1))
</code></pre>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="nl">"results"</span><span class="p">:[</span><span class="mi">1</span><span class="p">]}</span><span class="w">
</span></code></pre></div></div>

<ul>
  <li>Result is the number of repositories that user 1 has starred.</li>
</ul>

<h3 id="groupby">GroupBy</h3>

<p><strong>Spec:</strong></p>

<pre><code class="language-pql">GroupBy(&lt;ROWS_CALL&gt;, [&lt;ROWS_CALL&gt;...] , filter=&lt;ROW_CALL&gt;, having=Condition([&lt;COMPARISON_VALUE&gt; &lt;COMPARISON_OPERATOR&gt;] &lt;count|sum&gt; &lt;COMPARISON_OPERATOR&gt; &lt;COMPARISON_VALUE&gt;), aggregate=&lt;CALL&gt;, sort=&lt;SORT_DIRECTIVE_LIST&gt; , limit=&lt;UINT&gt; , offset=&lt;UINT&gt;)
</code></pre>

<p><strong>Description:</strong></p>

<p>GroupBy returns the count of the intersection of every combination of rows
taking one row each from the specified <code class="language-plaintext highlighter-rouge">Rows</code> calls. It returns only those
combinations for which the count is greater than 0.</p>

<p>The optional <code class="language-plaintext highlighter-rouge">filter</code> argument takes any type of <code class="language-plaintext highlighter-rouge">Row</code> query (e.g. Row, Union,
Intersect, etc.) which will be intersected with each result prior to returning
the count. This is analagous to a WHERE clause applied to a relational GROUP BY
query.</p>

<p>Paging through results is supported by passing the <code class="language-plaintext highlighter-rouge">previous</code> argument to each
of the <code class="language-plaintext highlighter-rouge">Rows</code> calls in the GroupBy. Take the last result from your previous
<code class="language-plaintext highlighter-rouge">GroupBy</code> query, and pass each row ID in that result as the <code class="language-plaintext highlighter-rouge">previous</code> argument
to each of the respective <code class="language-plaintext highlighter-rouge">Rows</code> queries in your next <code class="language-plaintext highlighter-rouge">GroupBy</code> query.</p>

<p>The optional <code class="language-plaintext highlighter-rouge">aggregate</code> argument can take either a <code class="language-plaintext highlighter-rouge">Sum()</code> or a
<code class="language-plaintext highlighter-rouge">Count(Distinct())</code> query.  <code class="language-plaintext highlighter-rouge">Sum(field=&lt;INTFIELD&gt;)</code> calculates the
sum and count of each group on the named field. This is similar functionality to using a <code class="language-plaintext highlighter-rouge">SUM()</code> in the
SELECT clause of a SQL GROUP BY query. Different counts might be observed than without the aggregate because this implies only records which have some value on the aggregated field (they cannot be null).</p>

<p>If <code class="language-plaintext highlighter-rouge">Count(Distinct(field=&lt;INTFIELD&gt;))</code> is passed as an aggregate, the
number of unique values on the aggregated field for each group will be
reported in the aggregate column of the results.</p>

<p>The optional <code class="language-plaintext highlighter-rouge">having</code> argument takes a <code class="language-plaintext highlighter-rouge">Condition</code> to apply to the results. This can be used to filter by the count within the group or the sum within the group.</p>

<p>The optional <code class="language-plaintext highlighter-rouge">sort</code> argument accepts a string specifying the sort order. This string is a comma-separated list of sort directives, each one optionally followed by <code class="language-plaintext highlighter-rouge">asc</code> or <code class="language-plaintext highlighter-rouge">desc</code> to specify the sort direction. <code class="language-plaintext highlighter-rouge">desc</code>, for “descending”, is the default. Valid sort directives are <code class="language-plaintext highlighter-rouge">count</code>, to sort by the groups’ counts, <code class="language-plaintext highlighter-rouge">sum</code> to sort by the sum of the groups’ values, or <code class="language-plaintext highlighter-rouge">aggregate</code>, to sort by the groups’ values as determined by the <code class="language-plaintext highlighter-rouge">aggregate</code> argument to <code class="language-plaintext highlighter-rouge">GroupBy</code>. For example, <code class="language-plaintext highlighter-rouge">sort="count asc, aggregate desc"</code> sorts first by the groups’ counts ascending, then by the aggregate value descending.</p>

<p>Sort directive details:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">count</code> can be used to sort by the always-present count values for each group.</li>
  <li><code class="language-plaintext highlighter-rouge">sum</code> or <code class="language-plaintext highlighter-rouge">aggregate</code> can be used to sort by the optional aggregate values when <code class="language-plaintext highlighter-rouge">Sum()</code> is specified as the aggregate call.</li>
  <li><code class="language-plaintext highlighter-rouge">aggregate</code> can also be used to sort by the optional aggregate values when <code class="language-plaintext highlighter-rouge">Count(Distinct())</code> is specified as the aggregate call.</li>
</ul>

<p>Contrary to the standard definition of <code class="language-plaintext highlighter-rouge">Rows</code>, GroupBy also supports bool and int fields.
It does not support decimal fields.</p>

<p>The optional <code class="language-plaintext highlighter-rouge">limit</code> argument limits the number of results returned. The results
are ordered, so as long as the data isn’t changing, the same query will return
the same result set.</p>

<p>The optional <code class="language-plaintext highlighter-rouge">offset</code> argument of value <code class="language-plaintext highlighter-rouge">n</code> skips the first <code class="language-plaintext highlighter-rouge">n</code> results of the call.
The results are ordered, so as long as the data isn’t changing, the same query will
return the same result set.</p>

<p><strong>Result Type:</strong> Array of “groups”. Each group is an object with a group key and
a count key. The count is an integer, and the group is an array of objects which
specify the field and row for each row that was intersected to get that result.</p>

<p><strong>Examples:</strong></p>

<p>A single <code class="language-plaintext highlighter-rouge">Rows</code> query.</p>
<pre><code class="language-pql">GroupBy(Rows(age))
</code></pre>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[{</span><span class="nl">"group"</span><span class="p">:[{</span><span class="nl">"field"</span><span class="p">:</span><span class="s2">"age"</span><span class="p">,</span><span class="nl">"rowID"</span><span class="p">:</span><span class="mi">18</span><span class="p">}],</span><span class="nl">"count"</span><span class="p">:</span><span class="mi">14</span><span class="p">},</span><span class="w">
</span><span class="p">{</span><span class="nl">"group"</span><span class="p">:[{</span><span class="nl">"field"</span><span class="p">:</span><span class="s2">"age"</span><span class="p">,</span><span class="nl">"rowID"</span><span class="p">:</span><span class="mi">22</span><span class="p">}],</span><span class="nl">"count"</span><span class="p">:</span><span class="mi">22</span><span class="p">},</span><span class="w">
</span><span class="p">{</span><span class="nl">"group"</span><span class="p">:[{</span><span class="nl">"field"</span><span class="p">:</span><span class="s2">"age"</span><span class="p">,</span><span class="nl">"rowID"</span><span class="p">:</span><span class="mi">29</span><span class="p">}],</span><span class="nl">"count"</span><span class="p">:</span><span class="mi">6</span><span class="p">}]</span><span class="w">
</span></code></pre></div></div>

<p>With two <code class="language-plaintext highlighter-rouge">Rows</code> queries - one with IDs and one with keys.</p>
<pre><code class="language-pql">GroupBy(Rows(age), Rows(job), limit=7)
</code></pre>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[{</span><span class="nl">"group"</span><span class="p">:[{</span><span class="nl">"field"</span><span class="p">:</span><span class="s2">"age"</span><span class="p">,</span><span class="nl">"rowID"</span><span class="p">:</span><span class="mi">18</span><span class="p">},{</span><span class="nl">"field"</span><span class="p">:</span><span class="s2">"job"</span><span class="p">,</span><span class="nl">"rowKey"</span><span class="p">:</span><span class="s2">"engineer"</span><span class="p">}],</span><span class="nl">"count"</span><span class="p">:</span><span class="mi">3</span><span class="p">},</span><span class="w">
 </span><span class="p">{</span><span class="nl">"group"</span><span class="p">:[{</span><span class="nl">"field"</span><span class="p">:</span><span class="s2">"age"</span><span class="p">,</span><span class="nl">"rowID"</span><span class="p">:</span><span class="mi">18</span><span class="p">},{</span><span class="nl">"field"</span><span class="p">:</span><span class="s2">"job"</span><span class="p">,</span><span class="nl">"rowKey"</span><span class="p">:</span><span class="s2">"management"</span><span class="p">}],</span><span class="nl">"count"</span><span class="p">:</span><span class="mi">1</span><span class="p">},</span><span class="w">
 </span><span class="p">{</span><span class="nl">"group"</span><span class="p">:[{</span><span class="nl">"field"</span><span class="p">:</span><span class="s2">"age"</span><span class="p">,</span><span class="nl">"rowID"</span><span class="p">:</span><span class="mi">18</span><span class="p">},{</span><span class="nl">"field"</span><span class="p">:</span><span class="s2">"job"</span><span class="p">,</span><span class="nl">"rowKey"</span><span class="p">:</span><span class="s2">"student"</span><span class="p">}],</span><span class="nl">"count"</span><span class="p">:</span><span class="mi">11</span><span class="p">},</span><span class="w">
 </span><span class="p">{</span><span class="nl">"group"</span><span class="p">:[{</span><span class="nl">"field"</span><span class="p">:</span><span class="s2">"age"</span><span class="p">,</span><span class="nl">"rowID"</span><span class="p">:</span><span class="mi">22</span><span class="p">},{</span><span class="nl">"field"</span><span class="p">:</span><span class="s2">"job"</span><span class="p">,</span><span class="nl">"rowKey"</span><span class="p">:</span><span class="s2">"engineer"</span><span class="p">}],</span><span class="nl">"count"</span><span class="p">:</span><span class="mi">6</span><span class="p">},</span><span class="w">
 </span><span class="p">{</span><span class="nl">"group"</span><span class="p">:[{</span><span class="nl">"field"</span><span class="p">:</span><span class="s2">"age"</span><span class="p">,</span><span class="nl">"rowID"</span><span class="p">:</span><span class="mi">22</span><span class="p">},{</span><span class="nl">"field"</span><span class="p">:</span><span class="s2">"job"</span><span class="p">,</span><span class="nl">"rowKey"</span><span class="p">:</span><span class="s2">"management"</span><span class="p">}],</span><span class="nl">"count"</span><span class="p">:</span><span class="mi">2</span><span class="p">},</span><span class="w">
 </span><span class="p">{</span><span class="nl">"group"</span><span class="p">:[{</span><span class="nl">"field"</span><span class="p">:</span><span class="s2">"age"</span><span class="p">,</span><span class="nl">"rowID"</span><span class="p">:</span><span class="mi">22</span><span class="p">},{</span><span class="nl">"field"</span><span class="p">:</span><span class="s2">"job"</span><span class="p">,</span><span class="nl">"rowKey"</span><span class="p">:</span><span class="s2">"student"</span><span class="p">}],</span><span class="nl">"count"</span><span class="p">:</span><span class="mi">4</span><span class="p">},</span><span class="w">
 </span><span class="p">{</span><span class="nl">"group"</span><span class="p">:[{</span><span class="nl">"field"</span><span class="p">:</span><span class="s2">"age"</span><span class="p">,</span><span class="nl">"rowID"</span><span class="p">:</span><span class="mi">29</span><span class="p">},{</span><span class="nl">"field"</span><span class="p">:</span><span class="s2">"job"</span><span class="p">,</span><span class="nl">"rowKey"</span><span class="p">:</span><span class="s2">"engineer"</span><span class="p">}],</span><span class="nl">"count"</span><span class="p">:</span><span class="mi">9</span><span class="p">}]</span><span class="w">
</span></code></pre></div></div>

<p>Getting the rest of the results from the previous example (paging).</p>
<pre><code class="language-pql">GroupBy(Rows(age, previous=29), Rows(job, previous="management"), limit=7)
</code></pre>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="w"> </span><span class="p">{</span><span class="nl">"group"</span><span class="p">:[{</span><span class="nl">"field"</span><span class="p">:</span><span class="s2">"age"</span><span class="p">,</span><span class="nl">"rowID"</span><span class="p">:</span><span class="mi">29</span><span class="p">},{</span><span class="nl">"field"</span><span class="p">:</span><span class="s2">"job"</span><span class="p">,</span><span class="nl">"rowKey"</span><span class="p">:</span><span class="s2">"engineer"</span><span class="p">}],</span><span class="nl">"count"</span><span class="p">:</span><span class="mi">9</span><span class="p">}]</span><span class="w">
</span><span class="p">[{</span><span class="nl">"group"</span><span class="p">:[{</span><span class="nl">"field"</span><span class="p">:</span><span class="s2">"age"</span><span class="p">,</span><span class="nl">"rowID"</span><span class="p">:</span><span class="mi">29</span><span class="p">},{</span><span class="nl">"field"</span><span class="p">:</span><span class="s2">"job"</span><span class="p">,</span><span class="nl">"rowKey"</span><span class="p">:</span><span class="s2">"management"</span><span class="p">}],</span><span class="nl">"count"</span><span class="p">:</span><span class="mi">3</span><span class="p">},</span><span class="w">
 </span><span class="p">{</span><span class="nl">"group"</span><span class="p">:[{</span><span class="nl">"field"</span><span class="p">:</span><span class="s2">"age"</span><span class="p">,</span><span class="nl">"rowID"</span><span class="p">:</span><span class="mi">29</span><span class="p">},{</span><span class="nl">"field"</span><span class="p">:</span><span class="s2">"job"</span><span class="p">,</span><span class="nl">"rowKey"</span><span class="p">:</span><span class="s2">"student"</span><span class="p">}],</span><span class="nl">"count"</span><span class="p">:</span><span class="mi">1</span><span class="p">}]</span><span class="w">
</span></code></pre></div></div>

<p>Matching groups with a minimum count of 5:</p>
<pre><code class="language-pql">GroupBy(Rows(age), Rows(job), having=Condition(count &gt;= 5))
</code></pre>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="w"> </span><span class="p">{</span><span class="nl">"group"</span><span class="p">:[{</span><span class="nl">"field"</span><span class="p">:</span><span class="s2">"age"</span><span class="p">,</span><span class="nl">"rowID"</span><span class="p">:</span><span class="mi">18</span><span class="p">},{</span><span class="nl">"field"</span><span class="p">:</span><span class="s2">"job"</span><span class="p">,</span><span class="nl">"rowKey"</span><span class="p">:</span><span class="s2">"student"</span><span class="p">}],</span><span class="nl">"count"</span><span class="p">:</span><span class="mi">11</span><span class="p">}</span><span class="err">,</span><span class="w">
 </span><span class="p">{</span><span class="nl">"group"</span><span class="p">:[{</span><span class="nl">"field"</span><span class="p">:</span><span class="s2">"age"</span><span class="p">,</span><span class="nl">"rowID"</span><span class="p">:</span><span class="mi">22</span><span class="p">},{</span><span class="nl">"field"</span><span class="p">:</span><span class="s2">"job"</span><span class="p">,</span><span class="nl">"rowKey"</span><span class="p">:</span><span class="s2">"engineer"</span><span class="p">}],</span><span class="nl">"count"</span><span class="p">:</span><span class="mi">6</span><span class="p">}</span><span class="err">,</span><span class="w">
 </span><span class="p">{</span><span class="nl">"group"</span><span class="p">:[{</span><span class="nl">"field"</span><span class="p">:</span><span class="s2">"age"</span><span class="p">,</span><span class="nl">"rowID"</span><span class="p">:</span><span class="mi">29</span><span class="p">},{</span><span class="nl">"field"</span><span class="p">:</span><span class="s2">"job"</span><span class="p">,</span><span class="nl">"rowKey"</span><span class="p">:</span><span class="s2">"engineer"</span><span class="p">}],</span><span class="nl">"count"</span><span class="p">:</span><span class="mi">9</span><span class="p">}]</span><span class="w">
</span></code></pre></div></div>

<p>Using the filter argument.</p>
<pre><code class="language-pql">GroupBy(Rows(age), Rows(job), limit=7, filter=Row(country=USA))
</code></pre>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[{</span><span class="nl">"group"</span><span class="p">:[{</span><span class="nl">"field"</span><span class="p">:</span><span class="s2">"age"</span><span class="p">,</span><span class="nl">"rowID"</span><span class="p">:</span><span class="mi">18</span><span class="p">},{</span><span class="nl">"field"</span><span class="p">:</span><span class="s2">"job"</span><span class="p">,</span><span class="nl">"rowKey"</span><span class="p">:</span><span class="s2">"engineer"</span><span class="p">}],</span><span class="nl">"count"</span><span class="p">:</span><span class="mi">1</span><span class="p">},</span><span class="w">
 </span><span class="p">{</span><span class="nl">"group"</span><span class="p">:[{</span><span class="nl">"field"</span><span class="p">:</span><span class="s2">"age"</span><span class="p">,</span><span class="nl">"rowID"</span><span class="p">:</span><span class="mi">18</span><span class="p">},{</span><span class="nl">"field"</span><span class="p">:</span><span class="s2">"job"</span><span class="p">,</span><span class="nl">"rowKey"</span><span class="p">:</span><span class="s2">"student"</span><span class="p">}],</span><span class="nl">"count"</span><span class="p">:</span><span class="mi">6</span><span class="p">},</span><span class="w">
 </span><span class="p">{</span><span class="nl">"group"</span><span class="p">:[{</span><span class="nl">"field"</span><span class="p">:</span><span class="s2">"age"</span><span class="p">,</span><span class="nl">"rowID"</span><span class="p">:</span><span class="mi">22</span><span class="p">},{</span><span class="nl">"field"</span><span class="p">:</span><span class="s2">"job"</span><span class="p">,</span><span class="nl">"rowKey"</span><span class="p">:</span><span class="s2">"engineer"</span><span class="p">}],</span><span class="nl">"count"</span><span class="p">:</span><span class="mi">3</span><span class="p">},</span><span class="w">
 </span><span class="p">{</span><span class="nl">"group"</span><span class="p">:[{</span><span class="nl">"field"</span><span class="p">:</span><span class="s2">"age"</span><span class="p">,</span><span class="nl">"rowID"</span><span class="p">:</span><span class="mi">22</span><span class="p">},{</span><span class="nl">"field"</span><span class="p">:</span><span class="s2">"job"</span><span class="p">,</span><span class="nl">"rowKey"</span><span class="p">:</span><span class="s2">"management"</span><span class="p">}],</span><span class="nl">"count"</span><span class="p">:</span><span class="mi">1</span><span class="p">},</span><span class="w">
 </span><span class="p">{</span><span class="nl">"group"</span><span class="p">:[{</span><span class="nl">"field"</span><span class="p">:</span><span class="s2">"age"</span><span class="p">,</span><span class="nl">"rowID"</span><span class="p">:</span><span class="mi">22</span><span class="p">},{</span><span class="nl">"field"</span><span class="p">:</span><span class="s2">"job"</span><span class="p">,</span><span class="nl">"rowKey"</span><span class="p">:</span><span class="s2">"student"</span><span class="p">}],</span><span class="nl">"count"</span><span class="p">:</span><span class="mi">3</span><span class="p">},</span><span class="w">
 </span><span class="p">{</span><span class="nl">"group"</span><span class="p">:[{</span><span class="nl">"field"</span><span class="p">:</span><span class="s2">"age"</span><span class="p">,</span><span class="nl">"rowID"</span><span class="p">:</span><span class="mi">29</span><span class="p">},{</span><span class="nl">"field"</span><span class="p">:</span><span class="s2">"job"</span><span class="p">,</span><span class="nl">"rowKey"</span><span class="p">:</span><span class="s2">"management"</span><span class="p">}],</span><span class="nl">"count"</span><span class="p">:</span><span class="mi">7</span><span class="p">}]</span><span class="w">
</span></code></pre></div></div>

<p>Using the Sum aggregate.</p>
<pre><code class="language-pql">GroupBy(Rows(job), aggregate=Sum(field=age))
</code></pre>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[{</span><span class="nl">"group"</span><span class="p">:[{</span><span class="nl">"field"</span><span class="p">:</span><span class="s2">"job"</span><span class="p">,</span><span class="nl">"rowKey"</span><span class="p">:</span><span class="s2">"engineer"</span><span class="p">}],</span><span class="nl">"count"</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="nl">"sum"</span><span class="p">:</span><span class="w"> </span><span class="mi">37</span><span class="p">},</span><span class="w">
 </span><span class="p">{</span><span class="nl">"group"</span><span class="p">:[{</span><span class="nl">"field"</span><span class="p">:</span><span class="s2">"job"</span><span class="p">,</span><span class="nl">"rowKey"</span><span class="p">:</span><span class="s2">"student"</span><span class="p">}],</span><span class="nl">"count"</span><span class="p">:</span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="nl">"sum"</span><span class="p">:</span><span class="w"> </span><span class="mi">129</span><span class="p">},</span><span class="w">
 </span><span class="p">{</span><span class="nl">"group"</span><span class="p">:[{</span><span class="nl">"field"</span><span class="p">:</span><span class="s2">"job"</span><span class="p">,</span><span class="nl">"rowKey"</span><span class="p">:</span><span class="s2">"management"</span><span class="p">}],</span><span class="nl">"count"</span><span class="p">:</span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="nl">"sum"</span><span class="p">:</span><span class="w"> </span><span class="mi">311</span><span class="p">}]</span><span class="w">

</span></code></pre></div></div>

<p>Using the Count(Distinct) aggregate. This returns the number of people in each job, and how many unique ages are represented in that group of people. And yes, unfortunately the result field is still named “sum” for now.</p>
<pre><code class="language-pql">GroupBy(Rows(job), aggregate=Count(Distinct(field=age)))
</code></pre>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[{</span><span class="nl">"group"</span><span class="p">:[{</span><span class="nl">"field"</span><span class="p">:</span><span class="s2">"job"</span><span class="p">,</span><span class="nl">"rowKey"</span><span class="p">:</span><span class="s2">"engineer"</span><span class="p">}],</span><span class="nl">"count"</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="nl">"sum"</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">},</span><span class="w">
 </span><span class="p">{</span><span class="nl">"group"</span><span class="p">:[{</span><span class="nl">"field"</span><span class="p">:</span><span class="s2">"job"</span><span class="p">,</span><span class="nl">"rowKey"</span><span class="p">:</span><span class="s2">"student"</span><span class="p">}],</span><span class="nl">"count"</span><span class="p">:</span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="nl">"sum"</span><span class="p">:</span><span class="w"> </span><span class="mi">5</span><span class="p">},</span><span class="w">
 </span><span class="p">{</span><span class="nl">"group"</span><span class="p">:[{</span><span class="nl">"field"</span><span class="p">:</span><span class="s2">"job"</span><span class="p">,</span><span class="nl">"rowKey"</span><span class="p">:</span><span class="s2">"management"</span><span class="p">}],</span><span class="nl">"count"</span><span class="p">:</span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="nl">"sum"</span><span class="p">:</span><span class="w"> </span><span class="mi">5</span><span class="p">}]</span><span class="w">
</span></code></pre></div></div>

<p>Sorting by count:</p>
<pre><code class="language-pql">GroupBy(Rows(job), sort="count")
</code></pre>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[{</span><span class="nl">"group"</span><span class="p">:[{</span><span class="nl">"field"</span><span class="p">:</span><span class="s2">"job"</span><span class="p">,</span><span class="nl">"rowKey"</span><span class="p">:</span><span class="s2">"management"</span><span class="p">}],</span><span class="nl">"count"</span><span class="p">:</span><span class="mi">7</span><span class="p">},</span><span class="w">
 </span><span class="p">{</span><span class="nl">"group"</span><span class="p">:[{</span><span class="nl">"field"</span><span class="p">:</span><span class="s2">"job"</span><span class="p">,</span><span class="nl">"rowKey"</span><span class="p">:</span><span class="s2">"student"</span><span class="p">}],</span><span class="nl">"count"</span><span class="p">:</span><span class="mi">6</span><span class="p">},</span><span class="w">
 </span><span class="p">{</span><span class="nl">"group"</span><span class="p">:[{</span><span class="nl">"field"</span><span class="p">:</span><span class="s2">"job"</span><span class="p">,</span><span class="nl">"rowKey"</span><span class="p">:</span><span class="s2">"engineer"</span><span class="p">}],</span><span class="nl">"count"</span><span class="p">:</span><span class="mi">1</span><span class="p">}]</span><span class="w">
</span></code></pre></div></div>

<p>Sorting by count and <code class="language-plaintext highlighter-rouge">Count(Distinct())</code> of another field:</p>
<pre><code class="language-pql">GroupBy(Rows(job), aggregate=Count(Distinct(field=projects)), sort="count, aggregate")
</code></pre>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[{</span><span class="nl">"group"</span><span class="p">:[{</span><span class="nl">"field"</span><span class="p">:</span><span class="s2">"job"</span><span class="p">,</span><span class="nl">"rowKey"</span><span class="p">:</span><span class="s2">"student"</span><span class="p">}],</span><span class="nl">"count"</span><span class="p">:</span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="nl">"aggregate"</span><span class="p">:</span><span class="w"> </span><span class="mi">5</span><span class="p">},</span><span class="w">
 </span><span class="p">{</span><span class="nl">"group"</span><span class="p">:[{</span><span class="nl">"field"</span><span class="p">:</span><span class="s2">"job"</span><span class="p">,</span><span class="nl">"rowKey"</span><span class="p">:</span><span class="s2">"management"</span><span class="p">}],</span><span class="nl">"count"</span><span class="p">:</span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="nl">"aggregate"</span><span class="p">:</span><span class="w"> </span><span class="mi">3</span><span class="p">},</span><span class="w">
 </span><span class="p">{</span><span class="nl">"group"</span><span class="p">:[{</span><span class="nl">"field"</span><span class="p">:</span><span class="s2">"job"</span><span class="p">,</span><span class="nl">"rowKey"</span><span class="p">:</span><span class="s2">"engineer"</span><span class="p">}],</span><span class="nl">"count"</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="nl">"aggregate"</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">}]</span><span class="w">
</span></code></pre></div></div>

<h3 id="topn">TopN</h3>

<p><strong>Spec:</strong></p>

<pre><code class="language-pql">TopN(&lt;FIELD&gt;, [ROW_CALL], [n=UINT])
</code></pre>

<p><strong>Description:</strong></p>

<p>Return the id and count of the top <code class="language-plaintext highlighter-rouge">n</code> rows (by count of bits) in the field.</p>

<p><strong>Result Type:</strong> array of (key,count) pairs sorted in descending order</p>

<p><strong>Caveats:</strong></p>

<p>In general, the order of the resulting row keys is not guaranteed to reflect the true order of bit counts across an index. The exact solution to the problem of computing the TopN counts is prohibitively expensive, so TopN is instead implemented as a heuristic. This provides a significant performance improvement, at the cost of uncertainty in the result order.</p>

<p>For guaranteed exact results, use <a href="#topk">TopK</a>, though be advised that it may be significantly slower, particularly for high cardinality fields. It can also be faster in some cases, especially when n is large, so experiment with your particular data set to see what works best.</p>

<p>The implementation is based on a per-shard cache. The accuracy of the results depends on how well the counts for the overall index are reflected in the individual shards (so TopN queries on a single-shard index are exact). If the distribution of bits across shards is uniform, shard counts are representative. This is often a reasonable assumption, especially for the top results for large data sets, in which counts might follow Zipfian, exponential, or other long-tail distributions. However, this assumption may not hold for some applications.</p>

<p>Additional implementation details:</p>

<ul>
  <li>The field’s cache size determines the number of sorted rows to maintain in the cache for purposes of TopN queries. There is a tradeoff between performance and accuracy; increasing the cache size will improve accuracy of results at the cost of performance. Note that this per-shard tradeoff is independent of the per-index performance/accuracy tradeoff mentioned above.</li>
  <li>Fields with cache type <code class="language-plaintext highlighter-rouge">ranked</code> will return the top rows sorted by count in descending order.</li>
  <li>Fields with cache type <code class="language-plaintext highlighter-rouge">lru</code> will maintain an LRU (Least Recently Used replacement policy) cache, thus a TopN query on this type of field will return rows sorted in order of most recently set bit.</li>
  <li>Once full, the cache will truncate the set of rows according to the field option CacheSize. Rows that straddle the limit and have the same count will be truncated in no particular order.</li>
</ul>

<p>See <a href="/reference/http-api#create-field">field creation</a> for more information about the cache.</p>

<p><strong>Examples:</strong></p>

<p>Basic TopN query:</p>
<pre><code class="language-pql">TopN(stargazer)
</code></pre>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="w">
    </span><span class="p">{</span><span class="w">
        </span><span class="nl">"id"</span><span class="p">:</span><span class="w"> </span><span class="mi">1240</span><span class="p">,</span><span class="w">
        </span><span class="nl">"count"</span><span class="p">:</span><span class="w"> </span><span class="mi">102</span><span class="w">
    </span><span class="p">},</span><span class="w">
    </span><span class="p">{</span><span class="w">
        </span><span class="nl">"id"</span><span class="p">:</span><span class="w"> </span><span class="mi">4734</span><span class="p">,</span><span class="w">
        </span><span class="nl">"count"</span><span class="p">:</span><span class="w"> </span><span class="mi">100</span><span class="w">
    </span><span class="p">},</span><span class="w">
    </span><span class="p">{</span><span class="w">
        </span><span class="nl">"id"</span><span class="p">:</span><span class="w"> </span><span class="mi">12709</span><span class="p">,</span><span class="w">
        </span><span class="nl">"count"</span><span class="p">:</span><span class="w"> </span><span class="mi">93</span><span class="w">
    </span><span class="p">},</span><span class="w">
    </span><span class="err">...</span><span class="w">
</span><span class="p">]</span><span class="w">
</span></code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">id</code> is a row ID (user ID)</li>
  <li><code class="language-plaintext highlighter-rouge">count</code> is a count of columns (repositories)</li>
  <li>Results are the number of bits set in the corresponding row (repositories that each user starred) in descending order for all rows (users) in the stargazer field. For example user 1240 starred 102 repositories, user 4734 starred 100 repositories, user 12709 starred 93 repository.</li>
</ul>

<p>Limit the number of results:</p>
<pre><code class="language-pql">TopN(stargazer, n=2)
</code></pre>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="w">
    </span><span class="p">{</span><span class="w">
        </span><span class="nl">"id"</span><span class="p">:</span><span class="w"> </span><span class="mi">1240</span><span class="p">,</span><span class="w">
        </span><span class="nl">"count"</span><span class="p">:</span><span class="w"> </span><span class="mi">102</span><span class="w">
    </span><span class="p">},</span><span class="w">
    </span><span class="p">{</span><span class="w">
        </span><span class="nl">"id"</span><span class="p">:</span><span class="w"> </span><span class="mi">4734</span><span class="p">,</span><span class="w">
        </span><span class="nl">"count"</span><span class="p">:</span><span class="w"> </span><span class="mi">100</span><span class="w">
    </span><span class="p">}</span><span class="w">
</span><span class="p">]</span><span class="w">
</span></code></pre></div></div>

<ul>
  <li>Results are the top two rows (users) sorted by number of bits set (repositories they’ve starred) in descending order.</li>
</ul>

<p>Filter based on an existing row:</p>
<pre><code class="language-pql">TopN(stargazer, Row(language=1), n=2)
</code></pre>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="w">
    </span><span class="p">{</span><span class="w">
        </span><span class="nl">"id"</span><span class="p">:</span><span class="w"> </span><span class="mi">1240</span><span class="p">,</span><span class="w">
        </span><span class="nl">"count"</span><span class="p">:</span><span class="w"> </span><span class="mi">35</span><span class="w">
    </span><span class="p">},</span><span class="w">
    </span><span class="p">{</span><span class="w">
        </span><span class="nl">"id"</span><span class="p">:</span><span class="w"> </span><span class="mi">7508</span><span class="p">,</span><span class="w">
        </span><span class="nl">"count"</span><span class="p">:</span><span class="w"> </span><span class="mi">32</span><span class="w">
    </span><span class="p">}</span><span class="w">
</span><span class="p">]</span><span class="w">
</span></code></pre></div></div>

<ul>
  <li>Results are the top two users (rows) sorted by the number of bits set in the intersection with row 1 of the language field (repositories that they’ve starred which are written in language 1).</li>
</ul>

<h3 id="topk">TopK</h3>

<p><strong>Spec:</strong></p>

<pre><code class="language-pql">TopK(&lt;FIELD&gt;, [k=UINT], [filter=ROW_CALL], [from=TIMESTAMP], [to=TIMESTAMP])
</code></pre>

<p><strong>Description:</strong></p>

<p>Return the id and count of the top <code class="language-plaintext highlighter-rouge">k</code> rows (by count of bits) in the set/time field.
If <code class="language-plaintext highlighter-rouge">k</code> is omitted, this will return a complete list including all rows with set bits.
If a <code class="language-plaintext highlighter-rouge">filter</code> is provided, then this will only count bits that intersect it.</p>

<p>When operating on a time field, the <code class="language-plaintext highlighter-rouge">from</code> and <code class="language-plaintext highlighter-rouge">to</code> arguments can be used to perform counts over a time range.
If the standard view of the time field has been disabled, the <code class="language-plaintext highlighter-rouge">from</code> and <code class="language-plaintext highlighter-rouge">to</code> arguments are required.</p>

<p><strong>Differences from TopN:</strong></p>

<ul>
  <li>TopN returns approximate results, and TopK returns exact results</li>
  <li>TopK supports time ranges, and TopN does not</li>
  <li>TopN requires a cache (ranked/lru) and TopK does not</li>
  <li>TopK computes total counts for all rows, and TopN does not</li>
  <li>TopK is deterministic, and TopN is not</li>
  <li>TopK does not currently support Tanimoto</li>
</ul>

<p>Usage notes:</p>
<ul>
  <li>TopK may take a second or longer to run on high-cardinality set fields</li>
  <li>TopK is fast when a sparse filter is applied, as this allows a large portion of work to be skipped</li>
  <li>When applying a filter which is correlated with row values, TopN and TopK may return dramatically different results</li>
</ul>

<p><strong>Result Type:</strong> array of (key,count) pairs sorted in descending order</p>

<p><strong>Examples:</strong></p>

<p>Basic TopK query:</p>
<pre><code class="language-pql">TopK(stargazer)
</code></pre>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="w">
    </span><span class="p">{</span><span class="w">
        </span><span class="nl">"id"</span><span class="p">:</span><span class="w"> </span><span class="mi">1240</span><span class="p">,</span><span class="w">
        </span><span class="nl">"count"</span><span class="p">:</span><span class="w"> </span><span class="mi">102</span><span class="w">
    </span><span class="p">},</span><span class="w">
    </span><span class="p">{</span><span class="w">
        </span><span class="nl">"id"</span><span class="p">:</span><span class="w"> </span><span class="mi">4734</span><span class="p">,</span><span class="w">
        </span><span class="nl">"count"</span><span class="p">:</span><span class="w"> </span><span class="mi">100</span><span class="w">
    </span><span class="p">},</span><span class="w">
    </span><span class="p">{</span><span class="w">
        </span><span class="nl">"id"</span><span class="p">:</span><span class="w"> </span><span class="mi">12709</span><span class="p">,</span><span class="w">
        </span><span class="nl">"count"</span><span class="p">:</span><span class="w"> </span><span class="mi">93</span><span class="w">
    </span><span class="p">},</span><span class="w">
    </span><span class="err">...</span><span class="w">
</span><span class="p">]</span><span class="w">
</span></code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">id</code> is a row ID (user ID)</li>
  <li><code class="language-plaintext highlighter-rouge">count</code> is a count of columns (repositories)</li>
  <li>Results are the number of bits set in the corresponding row (repositories that each user starred) in descending order for all rows (users) in the stargazer field. For example user 1240 starred 102 repositories, user 4734 starred 100 repositories, user 12709 starred 93 repository.</li>
</ul>

<p>Limit the number of results:</p>
<pre><code class="language-pql">TopK(stargazer, k=2)
</code></pre>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="w">
    </span><span class="p">{</span><span class="w">
        </span><span class="nl">"id"</span><span class="p">:</span><span class="w"> </span><span class="mi">1240</span><span class="p">,</span><span class="w">
        </span><span class="nl">"count"</span><span class="p">:</span><span class="w"> </span><span class="mi">102</span><span class="w">
    </span><span class="p">},</span><span class="w">
    </span><span class="p">{</span><span class="w">
        </span><span class="nl">"id"</span><span class="p">:</span><span class="w"> </span><span class="mi">4734</span><span class="p">,</span><span class="w">
        </span><span class="nl">"count"</span><span class="p">:</span><span class="w"> </span><span class="mi">100</span><span class="w">
    </span><span class="p">}</span><span class="w">
</span><span class="p">]</span><span class="w">
</span></code></pre></div></div>

<p>Filter by a time range:</p>
<pre><code class="language-pql">TopK(stargazer, from=2020-11-10T12:00, to=2020-11-10T23:59)
</code></pre>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="w">
    </span><span class="p">{</span><span class="w">
        </span><span class="nl">"id"</span><span class="p">:</span><span class="w"> </span><span class="mi">1240</span><span class="p">,</span><span class="w">
        </span><span class="nl">"count"</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="w">
    </span><span class="p">},</span><span class="w">
    </span><span class="p">{</span><span class="w">
        </span><span class="nl">"id"</span><span class="p">:</span><span class="w"> </span><span class="mi">4734</span><span class="p">,</span><span class="w">
        </span><span class="nl">"count"</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="w">
    </span><span class="p">}</span><span class="w">
</span><span class="p">]</span><span class="w">
</span></code></pre></div></div>

<ul>
  <li>Results are the top two users (rows) sorted by the number of bits set within in the time range (repositories that they starred during the afternoon of November 10).</li>
</ul>

<p>Filter based on an existing row:</p>
<pre><code class="language-pql">TopK(stargazer, k=2, filter=Row(language=1))
</code></pre>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="w">
    </span><span class="p">{</span><span class="w">
        </span><span class="nl">"id"</span><span class="p">:</span><span class="w"> </span><span class="mi">1240</span><span class="p">,</span><span class="w">
        </span><span class="nl">"count"</span><span class="p">:</span><span class="w"> </span><span class="mi">35</span><span class="w">
    </span><span class="p">},</span><span class="w">
    </span><span class="p">{</span><span class="w">
        </span><span class="nl">"id"</span><span class="p">:</span><span class="w"> </span><span class="mi">7508</span><span class="p">,</span><span class="w">
        </span><span class="nl">"count"</span><span class="p">:</span><span class="w"> </span><span class="mi">32</span><span class="w">
    </span><span class="p">}</span><span class="w">
</span><span class="p">]</span><span class="w">
</span></code></pre></div></div>

<ul>
  <li>Results are the top two users (rows) sorted by the number of bits set in the intersection with row 1 of the language field (repositories that they’ve starred which are written in language 1).</li>
</ul>

<p>Filter based on an existing row over time:</p>
<pre><code class="language-pql">TopK(stargazer, k=2, from=2019-01-01T00:00, to=2019-12-31T23:59, filter=Row(stargazer=1240, from=2019-01-01T00:00, to=2019-12-31T23:59))
</code></pre>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="w">
    </span><span class="p">{</span><span class="w">
        </span><span class="nl">"id"</span><span class="p">:</span><span class="w"> </span><span class="mi">1240</span><span class="p">,</span><span class="w">
        </span><span class="nl">"count"</span><span class="p">:</span><span class="w"> </span><span class="mi">102</span><span class="w">
    </span><span class="p">},</span><span class="w">
    </span><span class="p">{</span><span class="w">
        </span><span class="nl">"id"</span><span class="p">:</span><span class="w"> </span><span class="mi">4734</span><span class="p">,</span><span class="w">
        </span><span class="nl">"count"</span><span class="p">:</span><span class="w"> </span><span class="mi">51</span><span class="w">
    </span><span class="p">}</span><span class="w">
</span><span class="p">]</span><span class="w">
</span></code></pre></div></div>

<ul>
  <li>Results are the top two users (rows) sorted by the number of bits set in the intersection with row 1 of the same field over a time range (starred repositories in common with user 1, limited to stars in 2019).</li>
</ul>

<h2 id="aggregation-calls-read">Aggregation Calls (Read)</h2>

<h3 id="min">Min</h3>

<p><strong>Spec:</strong></p>

<pre><code class="language-pql">Min([ROW_CALL], field=&lt;FIELD&gt;)
</code></pre>

<p><strong>Description:</strong></p>

<p>Returns the minimum value of all BSI integer values in this <code class="language-plaintext highlighter-rouge">field</code>. If the optional <code class="language-plaintext highlighter-rouge">Row</code> call is supplied, only columns with set bits are considered, otherwise all columns are considered.</p>

<p><strong>Result Type:</strong> object with the min and count of columns containing the min value.</p>

<p><strong>Examples:</strong></p>

<p>Query the minimum value of a field (minimum size of all repositories):</p>
<pre><code class="language-pql">Min(field="diskusage")
</code></pre>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="nl">"value"</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span><span class="nl">"count"</span><span class="p">:</span><span class="mi">2</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<ul>
  <li>Result is the smallest value (repository size in kilobytes, here), plus the count of columns with that value.</li>
</ul>

<h3 id="max">Max</h3>

<p><strong>Spec:</strong></p>

<pre><code class="language-pql">Max([ROW_CALL], field=&lt;FIELD&gt;)
</code></pre>

<p><strong>Description:</strong></p>

<p>Returns the maximum value of all BSI integer values in this <code class="language-plaintext highlighter-rouge">field</code>. If the optional <code class="language-plaintext highlighter-rouge">Row</code> call is supplied, only columns with set bits are considered, otherwise all columns are considered.</p>

<p><strong>Result Type:</strong> object with the max and count of columns containing the max value.</p>

<p><strong>Examples:</strong></p>

<p>Query the maximum value of a field (maximum size of all repositories):</p>
<pre><code class="language-pql">Max(field="diskusage")
</code></pre>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="nl">"value"</span><span class="p">:</span><span class="mi">88</span><span class="p">,</span><span class="nl">"count"</span><span class="p">:</span><span class="mi">13</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<ul>
  <li>Result is the largest value (repository size in kilobytes, here), plus the count of columns with that value.</li>
</ul>

<h3 id="percentile">Percentile</h3>

<p><strong>Spec:</strong></p>

<pre><code class="language-pql">Percentile(field=&lt;FIELD&gt;, nth=&lt;FLOAT&gt;, filter=[ROW_CALL])
</code></pre>

<p><strong>Description:</strong>
<code class="language-plaintext highlighter-rouge">Percentile</code> computes the percentile score at or below which <code class="language-plaintext highlighter-rouge">nth</code> percent of values fall in the frequency distribution of the field’s values.</p>

<p>Unlike the mean or median, the calculation of percentiles has no standard definition, but rather a variety of possible implementations. For large data sets following a continuous probability distribution, the results of different implementations should be very similar. The algorithm used by FeatureBase is <em>interpolated</em> and <em>inclusive</em>.</p>

<p><em>Interpolated</em> means that the returned result value does not necessarily exist within the dataset. For example, for a field with two values, 1 and 5, the 50th percentile returned by FeatureBase is 3. In contrast, a <em>nearest-rank</em> implementation would return 1 or 5.</p>

<p><em>Inclusive</em> means that the returned result value represents the value <em>at or below which</em> <code class="language-plaintext highlighter-rouge">nth</code> percent of values fall (the percentile <em>includes</em> the specified value), rather than just the value <em>at which</em> <code class="language-plaintext highlighter-rouge">nth</code> percent of values fall. For example, for a field with the values [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], the 50th percentile <em>includes</em> the value 5, which is exactly at the 50th percentile level, so the value returned by FeatureBase is 5. In contrast, an <em>exclusive</em> implementation would return 4.</p>

<p>The <code class="language-plaintext highlighter-rouge">field</code> argument takes in the integer field on which the percentile will be
calculated. <code class="language-plaintext highlighter-rouge">Decimal</code> and <code class="language-plaintext highlighter-rouge">DateInt</code> fields are not supported.</p>

<p>The <code class="language-plaintext highlighter-rouge">nth</code> argument takes in either a whole number (such as 25) or a float 
(such as 99.999). This value should be within 0 and 100.0, both inclusive.
When <code class="language-plaintext highlighter-rouge">nth</code> is 0, <code class="language-plaintext highlighter-rouge">Percentile</code> returns the minimum value.
When <code class="language-plaintext highlighter-rouge">nth</code> is 100, <code class="language-plaintext highlighter-rouge">Percentile</code> returns the maximum value.
When <code class="language-plaintext highlighter-rouge">nth</code> is 50, <code class="language-plaintext highlighter-rouge">Percentile</code> returns a value that is close to, but not necessarily exactly equal to, the median value.</p>

<p>The optional <code class="language-plaintext highlighter-rouge">filter</code> argument takes any type of <code class="language-plaintext highlighter-rouge">Row</code> query, which is
intersected with the int field prior to computing the percentile.</p>

<p>Returns the computed Percentile and a count that is set to 1.</p>

<p><strong>Result Type:</strong> object with the computed percentile and count that is set to 1.</p>

<p><strong>Examples:</strong></p>

<p>Given only people with graduate degrees, get the 99th percentile age in the dataset.</p>
<pre><code class="language-pql">Percentile(field="age", nth=99.0, filter=Row(education="Doctorate and/or Professional degree"))
</code></pre>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="nl">"value"</span><span class="p">:</span><span class="mi">90</span><span class="p">,</span><span class="nl">"count"</span><span class="p">:</span><span class="mi">1</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<ul>
  <li>Result is the age below which 99% of all people with graduate degrees fall, i.e. the 99th percentile.</li>
</ul>

<h3 id="sum">Sum</h3>

<p><strong>Spec:</strong></p>

<pre><code class="language-pql">Sum([ROW_CALL], field=&lt;FIELD&gt;)
</code></pre>

<p><strong>Description:</strong></p>

<p>Returns the count and computed sum of all BSI integer values in the <code class="language-plaintext highlighter-rouge">field</code>. If the optional <code class="language-plaintext highlighter-rouge">Row</code> call is supplied, columns with set bits are summed, otherwise the sum is across all columns.</p>

<p><strong>Result Type:</strong> object with the computed sum and count of the values in the integer field.</p>

<p><strong>Examples:</strong></p>

<p>Query the size of all repositories.</p>
<pre><code class="language-pql">Sum(field="diskusage")
</code></pre>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="nl">"value"</span><span class="p">:</span><span class="mi">10</span><span class="p">,</span><span class="nl">"count"</span><span class="p">:</span><span class="mi">3</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<ul>
  <li>Result is the sum of all values (total size of all repositories in kilobytes, here), plus the count of columns.</li>
</ul>

<h2 id="exploratory-calls-read">Exploratory Calls (Read)</h2>

<h3 id="extract">Extract</h3>

<p><strong>Spec:</strong></p>

<pre><code class="language-pql">Extract(&lt;ROW_CALL&gt;, [&lt;ROWS_CALL&gt;...])
</code></pre>

<p><strong>Description:</strong></p>

<p>Extract intersects a set of columns with a set of rows in order to extract a subset of the index.
The result is a table consisting of the matched columns and the rows which they intersect.
This is similar to a select query in a SQL database.</p>

<p>Contrary to the standard definition of Rows, Extract works on all field types.</p>

<p>:::note
Extract does not currently support filters on the backing <code class="language-plaintext highlighter-rouge">ROWS_CALL</code>s.
:::</p>

<p><strong>Result Type:</strong> Object with an array of the selected fields and an array of the selected columns.
The column array contains objects containing a column identifier and an array of field values.
Field values are typed as such:</p>

<table>
  <thead>
    <tr>
      <th>Field Type</th>
      <th><code class="language-plaintext highlighter-rouge">type</code></th>
      <th>JSON Value Type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Bool</td>
      <td><code class="language-plaintext highlighter-rouge">"bool"</code></td>
      <td>boolean</td>
    </tr>
    <tr>
      <td>Mutex (unkeyed)</td>
      <td><code class="language-plaintext highlighter-rouge">"uint64"</code></td>
      <td>positive integer ID or <code class="language-plaintext highlighter-rouge">null</code></td>
    </tr>
    <tr>
      <td>Mutex (keyed)</td>
      <td><code class="language-plaintext highlighter-rouge">"string"</code></td>
      <td>string or <code class="language-plaintext highlighter-rouge">null</code></td>
    </tr>
    <tr>
      <td>Integer</td>
      <td><code class="language-plaintext highlighter-rouge">"int64"</code></td>
      <td>integer or <code class="language-plaintext highlighter-rouge">null</code></td>
    </tr>
    <tr>
      <td>Integer (foreign-index)</td>
      <td><code class="language-plaintext highlighter-rouge">"string"</code></td>
      <td>string or <code class="language-plaintext highlighter-rouge">null</code></td>
    </tr>
    <tr>
      <td>Decimal</td>
      <td><code class="language-plaintext highlighter-rouge">"decimal"</code></td>
      <td>FeatureBase decimal value or <code class="language-plaintext highlighter-rouge">null</code></td>
    </tr>
    <tr>
      <td>Set (unkeyed)</td>
      <td><code class="language-plaintext highlighter-rouge">"[]uint64"</code></td>
      <td>array of positive integer IDs</td>
    </tr>
    <tr>
      <td>Set (keyed)</td>
      <td><code class="language-plaintext highlighter-rouge">"[]string"</code></td>
      <td>array of strings</td>
    </tr>
    <tr>
      <td>Time (unkeyed)</td>
      <td><code class="language-plaintext highlighter-rouge">"[]uint64"</code></td>
      <td>array of positive integer IDs</td>
    </tr>
    <tr>
      <td>Time (keyed)</td>
      <td><code class="language-plaintext highlighter-rouge">"[]string"</code></td>
      <td>array of strings</td>
    </tr>
  </tbody>
</table>

<p>:::note
Time fields are treated as sets, and include all values that are set at any time.
:::</p>

<p><strong>Examples:</strong></p>

<p>List all languages associated used in each specified repository:</p>
<pre><code class="language-pql">Extract(ConstRow(columns=[1,2,3]), Rows(language))
</code></pre>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"fields"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
    </span><span class="p">{</span><span class="w">
      </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"language"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"[]string"</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">],</span><span class="w">
  </span><span class="nl">"columns"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
    </span><span class="p">{</span><span class="w">
      </span><span class="nl">"column"</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">
      </span><span class="nl">"rows"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
        </span><span class="p">[</span><span class="w">
          </span><span class="s2">"C"</span><span class="p">,</span><span class="w">
          </span><span class="s2">"Java"</span><span class="p">,</span><span class="w">
          </span><span class="s2">"Python"</span><span class="w">
        </span><span class="p">]</span><span class="w">
      </span><span class="p">]</span><span class="w">
    </span><span class="p">},</span><span class="w">
    </span><span class="p">{</span><span class="w">
      </span><span class="nl">"column"</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w">
      </span><span class="nl">"rows"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
        </span><span class="p">[</span><span class="w">
          </span><span class="s2">"Go"</span><span class="w">
        </span><span class="p">]</span><span class="w">
      </span><span class="p">]</span><span class="w">
    </span><span class="p">},</span><span class="w">
    </span><span class="p">{</span><span class="w">
      </span><span class="nl">"column"</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">
      </span><span class="nl">"rows"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
        </span><span class="p">[</span><span class="w">
          </span><span class="s2">"Python"</span><span class="p">,</span><span class="w">
          </span><span class="s2">"JavaScript"</span><span class="w">
        </span><span class="p">]</span><span class="w">
      </span><span class="p">]</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<h2 id="write-operations">Write Operations</h2>

<h3 id="store">Store</h3>

<p><strong>Spec:</strong></p>

<pre><code class="language-pql">Store(&lt;ROW_CALL&gt;, &lt;FIELD&gt;=&lt;ROW&gt;)
</code></pre>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ROW_CALL</code> - The query which will have its results cached. Must be a <code class="language-plaintext highlighter-rouge">ROW_CALL</code>, that is, any query that returns a Row. Allowed queries are: <code class="language-plaintext highlighter-rouge">Row</code>, <code class="language-plaintext highlighter-rouge">Intersect</code>, <code class="language-plaintext highlighter-rouge">Union</code>, <code class="language-plaintext highlighter-rouge">Difference</code>, <code class="language-plaintext highlighter-rouge">Xor</code>, <code class="language-plaintext highlighter-rouge">Not</code>, <code class="language-plaintext highlighter-rouge">ConstRow</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">FIELD</code> - The name of a field of type <code class="language-plaintext highlighter-rouge">Set</code>, typically with <code class="language-plaintext highlighter-rouge">cacheType</code> set to <code class="language-plaintext highlighter-rouge">none</code> to avoid unnecessary overhead. If the specified field does not exist, it is created with <code class="language-plaintext highlighter-rouge">cacheType</code> set to <code class="language-plaintext highlighter-rouge">none</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">ROW</code> - The value which will be set in <code class="language-plaintext highlighter-rouge">field_name</code> for each result returned in the query. This flag value will typically be used in a future query which uses this <code class="language-plaintext highlighter-rouge">Store</code> result, in order to filter the future query. Note that row keys can be used here.</li>
</ul>

<p><strong>Description:</strong></p>

<p><code class="language-plaintext highlighter-rouge">Store</code> writes the results of <code class="language-plaintext highlighter-rouge">&lt;ROW_CALL&gt;</code> to the specified row. If the row already exists, it will be replaced. The destination field must be of field type <code class="language-plaintext highlighter-rouge">set</code>.</p>

<p>The <code class="language-plaintext highlighter-rouge">Store()</code> query allows a user to execute a query and store the result set as an additional row in a field. This result set can then be used in future queries. Note that the query must return a “Row” result, e.g. Row, Intersect, Union, etc.</p>

<p>If the result set from the <code class="language-plaintext highlighter-rouge">Store</code> becomes stale and needs an update, executing the <code class="language-plaintext highlighter-rouge">Store</code> function again on the same query will refresh the result set, replacing the complete result set from a previous store operation.</p>

<p>Multiple named <code class="language-plaintext highlighter-rouge">Store</code> results sets can be maintained in the same index, representing different query results.</p>

<p><strong>Result Type:</strong> boolean</p>

<p>Upon success, this method always returns <code class="language-plaintext highlighter-rouge">true</code>. A future version of FeatureBase may use this boolean result to indicate whether or not the data in the destination row was changed by the <code class="language-plaintext highlighter-rouge">Store</code> call.</p>

<p><strong>Examples:</strong></p>

<p>Store the contents of stargazer row 1 into stargazer row 2:</p>
<pre><code class="language-pql">Store(Row(stargazer=1), stargazer=2)
</code></pre>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="nl">"results"</span><span class="p">:[</span><span class="kc">true</span><span class="p">]}</span><span class="w">
</span></code></pre></div></div>

<p>Store the results of the intersection of stargazer rows 10 and 11 into stargazer row 20.</p>
<pre><code class="language-pql">Store(Intersect(Row(stargazer=10), Row(stargazer=11)), stargazer=20)
</code></pre>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="nl">"results"</span><span class="p">:[</span><span class="kc">true</span><span class="p">]}</span><span class="w">
</span></code></pre></div></div>

<p><strong>Detailed Example:</strong></p>
<pre><code class="language-pql">Store(
    Intersect(
        Not(Row(bools="has_season_pass")),
        Row(bools="all_fans"))
    ),
    ticket_buyers=1
)
</code></pre>

<p>Note: if <code class="language-plaintext highlighter-rouge">ticket_buyers</code> does not exist before <code class="language-plaintext highlighter-rouge">Store</code> is called, it will be created automatically and set to:</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="w"> </span><span class="nl">"cacheType"</span><span class="p">:</span><span class="w"> </span><span class="s2">"none"</span><span class="w">
</span></code></pre></div></div>

<p>This will prevent unnecessary overhead in Molecula, calculating TopN caches, etc.</p>

<p><strong>Example Application:</strong></p>

<p>Original Query:</p>

<pre><code class="language-pql">Intersect(
    Row(age_range="18-24"),
    Row(education="college"),
    Row(zip_code="78750"),
    Not(Row(bools="has_season_pass")),
    Row(bools="all_fans")
)
Intersect(
    Row(age_range="25-34"),
    Row(education="college"),
    Row(zip_code="78750"),
    Not(Row(bools="has_season_pass")),
    Row(bools="all_fans")
)
[...]
</code></pre>

<p>Because this series of <code class="language-plaintext highlighter-rouge">Intersect</code> queries has a common subquery, it can be separated and cached:</p>

<pre><code class="language-pql">Store(
    Intersect(
        Not(Row(bools="has_season_pass")),
        Row(bools="all_fans")
    ),
    ticket_buyers=1
)
</code></pre>

<p>The final query:</p>

<pre><code class="language-pql">Intersect(
    Row(age_range="18-24"),
    Row(education="college"),
    Row(zip_code="78750"),
    Row(ticket_buyers=1)
)
Intersect(
    Row(age_range="25-34"),
    Row(education="college"),
    Row(zip_code="78750"),
    Row(ticket_buyers=1)
)
</code></pre>

<p>This can significantly improve performance for larger batches of queries.</p>

<p><code class="language-plaintext highlighter-rouge">Store</code> results can be used within other <code class="language-plaintext highlighter-rouge">Store</code> calls. For instance, having created a row representing “all fans without season passes”, a successive <code class="language-plaintext highlighter-rouge">Store</code> call can be used to create a list of fans without season passes, and with a specific age range and education level:</p>

<pre><code class="language-pql">Store(
    Intersect(
        ticket_buyers=1,
        Row(age_range="18-24"),
        Row(education="college"),
        ticket_buyers=2
    )
)
</code></pre>

<p>Then this row of the <code class="language-plaintext highlighter-rouge">ticket_buyers</code> field could be used for queries against that particular age_range/education combination, replacing four reads and three intersection computations with a single read in all the following queries.</p>

<p>It is safe to read from and write to the same row in a single <code class="language-plaintext highlighter-rouge">Store</code> call. For example, <code class="language-plaintext highlighter-rouge">Store(Union(Row(scratch=0),Row(newData=1)), scratch=0)</code> will perform a union including the <code class="language-plaintext highlighter-rouge">scratch=0</code> row, and then write the result to that same row.</p>

<h3 id="clearrow">ClearRow</h3>

<p><strong>Spec:</strong></p>

<pre><code class="language-pql">ClearRow(&lt;FIELD&gt;=&lt;ROW&gt;)
</code></pre>

<p><strong>Description:</strong></p>

<p><code class="language-plaintext highlighter-rouge">ClearRow</code> sets all bits to 0 in a given row of the binary matrix, thus disassociating the given row in the given field from all columns.</p>

<p><strong>Result Type:</strong> boolean</p>

<p>A return value of <code class="language-plaintext highlighter-rouge">true</code> indicates that at least one column was toggled from 1 to 0.</p>

<p>A return value of <code class="language-plaintext highlighter-rouge">false</code> indicates that all bits in the row were already 0 and nothing changed.</p>

<p><strong>Examples:</strong></p>

<p>Clear all bit in row 1 in the stargazer field:</p>
<pre><code class="language-pql">ClearRow(stargazer=1)
</code></pre>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="nl">"results"</span><span class="p">:[</span><span class="kc">true</span><span class="p">]}</span><span class="w">
</span></code></pre></div></div>

<p>This represents removing the relationship between the user with id=1 and all repositories.</p>

<h3 id="set">Set</h3>

<p><strong>Spec:</strong></p>

<pre><code class="language-pql">Set(&lt;COLUMN&gt;, &lt;FIELD&gt;=&lt;ROW&gt;, [TIMESTAMP])
</code></pre>

<p><strong>Description:</strong></p>

<p><code class="language-plaintext highlighter-rouge">Set</code> assigns a value of 1 to a bit in the binary matrix, thus associating the given row (the <code class="language-plaintext highlighter-rouge">&lt;ROW&gt;</code> value) in the given field with the given column.</p>

<p>:::note
While using “Set” in PQL is a convenient way to get familiar with FeatureBase, it’s almost always better to use a dedicated ingest tool. See <a href="/explanations/ingesters">ingesters</a> for details.
:::</p>

<p><strong>Result Type:</strong> boolean</p>

<p>A return value of <code class="language-plaintext highlighter-rouge">true</code> indicates that the bit was changed to 1.</p>

<p>A return value of <code class="language-plaintext highlighter-rouge">false</code> indicates that the bit was already set to 1 and nothing changed.</p>

<p><strong>Examples:</strong></p>

<p>Set the bit at row 1, column 10:</p>
<pre><code class="language-pql">Set(10, stargazer=1)
</code></pre>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="nl">"results"</span><span class="p">:[</span><span class="kc">true</span><span class="p">]}</span><span class="w">
</span></code></pre></div></div>

<p>This sets a bit in the stargazer field, representing that the user with id=1 has starred the repository with id=10.</p>

<p>Set also supports providing a timestamp. To write the date that a user starred a repository:</p>
<pre><code class="language-pql">Set(10, stargazer=1, 2016-01-01T00:00)
</code></pre>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="nl">"results"</span><span class="p">:[</span><span class="kc">true</span><span class="p">]}</span><span class="w">
</span></code></pre></div></div>

<p>Set multiple bits in a single request:</p>
<pre><code class="language-pql">Set(10, stargazer=1) Set(20, stargazer=1) Set(10, stargazer=2) Set(30, stargazer=2)
</code></pre>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="nl">"results"</span><span class="p">:[</span><span class="kc">false</span><span class="p">,</span><span class="kc">true</span><span class="p">,</span><span class="kc">true</span><span class="p">,</span><span class="kc">true</span><span class="p">]}</span><span class="w">
</span></code></pre></div></div>

<p>Set the field “pullrequests” to integer value 2 at column 10:</p>
<pre><code class="language-pql">Set(10, pullrequests=2)
</code></pre>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="nl">"results"</span><span class="p">:[</span><span class="kc">true</span><span class="p">]}</span><span class="w">
</span></code></pre></div></div>

<h3 id="clear">Clear</h3>

<p><strong>Spec:</strong></p>

<pre><code class="language-pql">Clear(&lt;COLUMN&gt;, &lt;FIELD&gt;=&lt;ROW&gt;)
</code></pre>

<p><strong>Description:</strong></p>

<p><code class="language-plaintext highlighter-rouge">Clear</code> assigns a value of 0 to a bit in the binary matrix, thus disassociating the given row in the given field from the given column. The bit to be cleared is specified by the intersection of <code class="language-plaintext highlighter-rouge">&lt;COLUMN&gt;</code> and <code class="language-plaintext highlighter-rouge">&lt;FIELD&gt;=&lt;ROW&gt;</code>.  <code class="language-plaintext highlighter-rouge">&lt;COLUMN&gt;</code> and <code class="language-plaintext highlighter-rouge">&lt;ROW&gt;</code> can each be specified as an integer ID, or for string-keyed Columns and Rows, as the keyed string value.</p>

<p>To clear a value from an int field, you can pass any int value as the <code class="language-plaintext highlighter-rouge">&lt;ROW&gt;</code> value, and the field will be set to null. You do not need to know the particular value of the int field in order to clear it.</p>

<p>e.g. To clear the int field myint from column 10, regardless of current value:</p>
<pre><code class="language-pql">Clear(10, myint=0)
</code></pre>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="nl">"results"</span><span class="p">:[</span><span class="kc">true</span><span class="p">]}</span><span class="w">
</span></code></pre></div></div>

<p>Note that clearing a column on a time field will remove all data for that column.</p>

<p><strong>Result Type:</strong> boolean</p>

<p>A return value of <code class="language-plaintext highlighter-rouge">true</code> indicates that the bit was toggled from 1 to 0.</p>

<p>A return value of <code class="language-plaintext highlighter-rouge">false</code> indicates that the bit was already set to 0 and nothing changed.</p>

<p><strong>Examples:</strong></p>

<p>Clear the bit at row 1 and column 10 in the stargazer field:</p>
<pre><code class="language-pql">Clear(10, stargazer=1)
</code></pre>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="nl">"results"</span><span class="p">:[</span><span class="kc">true</span><span class="p">]}</span><span class="w">
</span></code></pre></div></div>

<p>This represents removing the relationship between the user with id=1 and the repository with id=10.</p>

<p>To clear the String field <code class="language-plaintext highlighter-rouge">language</code> for the value <code class="language-plaintext highlighter-rouge">Java</code> from the keyed column <code class="language-plaintext highlighter-rouge">ABC</code>:</p>
<pre><code class="language-pql">Clear("ABC", language="Java")
</code></pre>
<p>This removes the relationship between the record <code class="language-plaintext highlighter-rouge">ABC</code> and the value <code class="language-plaintext highlighter-rouge">Java</code> in the <code class="language-plaintext highlighter-rouge">language</code> field.</p>

<h3 id="delete">Delete</h3>

<p><strong>Spec:</strong></p>

<pre><code class="language-pql">Delete(&lt;ROW_CALL&gt;)
</code></pre>

<p><strong>Description:</strong></p>

<p><code class="language-plaintext highlighter-rouge">Delete</code> deletes the set of columns from an index specified by a <code class="language-plaintext highlighter-rouge">ROW_CALL</code>. It is potentially a very heavy operation. It iterates over all fields and views in a set of provided columns, removing the columns. It also removes all data from fields, existence bits, and key translation for the provided columns for all replicas in the cluster.</p>

<p><code class="language-plaintext highlighter-rouge">Delete</code> does not support deleting specific fields, only full records based on a <code class="language-plaintext highlighter-rouge">ROW_CALL</code>. It doesn’t support deletes from Kafka Delete Consumer or two separate clusters.</p>

<p><strong>Result Type:</strong>  boolean</p>

<p>A return value of <code class="language-plaintext highlighter-rouge">true</code> indicates that the columns to delete were found AND deleted.</p>

<p>A return value of <code class="language-plaintext highlighter-rouge">false</code> indicates that the columns to delete were NOT found OR that they WERE found but not deleted.</p>

<p><strong>Examples:</strong></p>

<p>Delete a specific set of records identified by column ID.</p>
<pre><code class="language-pql">Delete(ConstRow(columns=[1,2,3]))
</code></pre>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="nl">"results"</span><span class="p">:[</span><span class="kc">true</span><span class="p">]}</span><span class="w">
</span></code></pre></div></div>

<p>Delete a calculated set of records</p>
<pre><code class="language-pql">Delete(Intersect(Row(setfield=20),Row(gender="m")))
</code></pre>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="nl">"columns"</span><span class="p">:[</span><span class="mi">30</span><span class="p">]}</span><span class="w">
</span></code></pre></div></div>

<p>Note: while you could delete all records in an index using <code class="language-plaintext highlighter-rouge">Delete(All())</code>, this is not recommended, as <a href="/reference/grpc-api#deleteindex">dropping an index</a> would be a much more performant way of deleting all records in an index.</p>

<h2 id="other-operations">Other Operations</h2>

<h3 id="options">Options</h3>

<p><strong>Spec:</strong></p>

<pre><code class="language-pql">Options(&lt;CALL&gt;, shards=[UINT ...])
</code></pre>

<p><strong>Description:</strong></p>

<p>Modifies the given query as follows:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">shards</code>: Run the query using only the data from the given shards. By default, the entire data set (i.e. data from all shards) is used.</li>
</ul>

<p><strong>Result Type:</strong> Same result type as <code class="language-plaintext highlighter-rouge">&lt;CALL&gt;</code>.</p>

<p><strong>Examples:</strong></p>

<p>Run the query against shards 0 and 2 only:</p>
<pre><code class="language-pql">Options(Row(f1=10), shards=[0, 2])
</code></pre>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="nl">"columns"</span><span class="p">:[</span><span class="mi">100</span><span class="p">,</span><span class="w"> </span><span class="mi">2097152</span><span class="p">]}</span><span class="w">
</span></code></pre></div></div>

                </section>
            </article>
    
            <!-- Right sidebar -->
            <nav class="container__right">
                <div>Applies to</div>

                <span>Please <a href="https://github.com/molecula/documentation/edit/gh-pages/reference/pql.md">help improve this article</a>.</span>

                <div>
                    <span>
                        Modified: 
                    </span>
                </div>

                <div>Feedback?</div>
            </nav>
        </main>
        <footer>
            <p> &copy; 2022 Molecula Corp.</p>
        </footer>
    </div>
  </body>
</html>